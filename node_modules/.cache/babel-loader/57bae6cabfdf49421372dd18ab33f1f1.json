{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject8() {\n  var data = _taggedTemplateLiteral([\"\", \".compare(\", \", \", \") \", \" 0\"]);\n\n  _templateObject8 = function _templateObject8() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject7() {\n  var data = _taggedTemplateLiteral([\"\", \"\", \"\"]);\n\n  _templateObject7 = function _templateObject7() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject6() {\n  var data = _taggedTemplateLiteral([\"typeof \", \".compare != \\\"function\\\"\"]);\n\n  _templateObject6 = function _templateObject6() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject5() {\n  var data = _taggedTemplateLiteral([\"\", \" instanceof RegExp\"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteral([\"typeof \", \" != \\\"object\\\"\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\", \"[\", \"]\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"{comparison: \", \", limit: \", \"}\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"should be \", \" \", \"\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatLimitDefinition = void 0;\n\nvar ajv_1 = require(\"ajv\");\n\nvar codegen_1 = require(\"ajv/dist/compile/codegen\");\n\nvar ops = codegen_1.operators;\nvar KWDs = {\n  formatMaximum: {\n    okStr: \"<=\",\n    ok: ops.LTE,\n    fail: ops.GT\n  },\n  formatMinimum: {\n    okStr: \">=\",\n    ok: ops.GTE,\n    fail: ops.LT\n  },\n  formatExclusiveMaximum: {\n    okStr: \"<\",\n    ok: ops.LT,\n    fail: ops.GTE\n  },\n  formatExclusiveMinimum: {\n    okStr: \">\",\n    ok: ops.GT,\n    fail: ops.LTE\n  }\n};\nvar error = {\n  message: function message(_ref) {\n    var keyword = _ref.keyword,\n        schemaCode = _ref.schemaCode;\n    return codegen_1.str(_templateObject(), KWDs[keyword].okStr, schemaCode);\n  },\n  params: function params(_ref2) {\n    var keyword = _ref2.keyword,\n        schemaCode = _ref2.schemaCode;\n    return codegen_1._(_templateObject2(), KWDs[keyword].okStr, schemaCode);\n  }\n};\nexports.formatLimitDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        schemaCode = cxt.schemaCode,\n        keyword = cxt.keyword,\n        it = cxt.it;\n    var opts = it.opts,\n        self = it.self;\n    if (!opts.validateFormats) return;\n    var fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n    if (fCxt.$data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      var fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      var fmt = gen.const(\"fmt\", codegen_1._(_templateObject3(), fmts, fCxt.schemaCode));\n      cxt.fail$data(codegen_1.or(codegen_1._(_templateObject4(), fmt), codegen_1._(_templateObject5(), fmt), codegen_1._(_templateObject6(), fmt), compareCode(fmt)));\n    }\n\n    function validateFormat() {\n      var format = fCxt.schema;\n      var fmtDef = self.formats[format];\n      if (!fmtDef || fmtDef === true) return;\n\n      if (typeof fmtDef != \"object\" || fmtDef instanceof RegExp || typeof fmtDef.compare != \"function\") {\n        throw new Error(\"\\\"\".concat(keyword, \"\\\": format \\\"\").concat(format, \"\\\" does not define \\\"compare\\\" function\"));\n      }\n\n      var fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? codegen_1._(_templateObject7(), opts.code.formats, codegen_1.getProperty(format)) : undefined\n      });\n      cxt.fail$data(compareCode(fmt));\n    }\n\n    function compareCode(fmt) {\n      return codegen_1._(_templateObject8(), fmt, data, schemaCode, KWDs[keyword].fail);\n    }\n  },\n\n  dependencies: [\"format\"]\n};\n\nvar formatLimitPlugin = function formatLimitPlugin(ajv) {\n  ajv.addKeyword(exports.formatLimitDefinition);\n  return ajv;\n};\n\nexports.default = formatLimitPlugin;","map":{"version":3,"sources":["../src/limit.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = require(\"ajv\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    formatMaximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    formatMinimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    formatExclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    formatExclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nexports.formatLimitDefinition = {\n    keyword: Object.keys(KWDs),\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, keyword, it } = cxt;\n        const { opts, self } = it;\n        if (!opts.validateFormats)\n            return;\n        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n        if (fCxt.$data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fmt = gen.const(\"fmt\", codegen_1._ `${fmts}[${fCxt.schemaCode}]`);\n            cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != \"object\"`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n        }\n        function validateFormat() {\n            const format = fCxt.schema;\n            const fmtDef = self.formats[format];\n            if (!fmtDef || fmtDef === true)\n                return;\n            if (typeof fmtDef != \"object\" ||\n                fmtDef instanceof RegExp ||\n                typeof fmtDef.compare != \"function\") {\n                throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n            }\n            const fmt = gen.scopeValue(\"formats\", {\n                key: format,\n                ref: fmtDef,\n                code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,\n            });\n            cxt.fail$data(compareCode(fmt));\n        }\n        function compareCode(fmt) {\n            return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n        }\n    },\n    dependencies: [\"format\"],\n};\nconst formatLimitPlugin = (ajv) => {\n    ajv.addKeyword(exports.formatLimitDefinition);\n    return ajv;\n};\nexports.default = formatLimitPlugin;\n//# sourceMappingURL=limit.js.map"]},"metadata":{},"sourceType":"script"}