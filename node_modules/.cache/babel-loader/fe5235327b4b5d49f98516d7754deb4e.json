{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\", \" > \", \"\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\", \".length\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateTuple = void 0;\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar code_1 = require(\"../code\");\n\nvar def = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n\n  code(cxt) {\n    var schema = cxt.schema,\n        it = cxt.it;\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema);\n    it.items = true;\n    if ((0, util_1.alwaysValidSchema)(it, schema)) return;\n    cxt.ok((0, code_1.validateArray)(cxt));\n  }\n\n};\n\nfunction validateTuple(cxt, extraItems) {\n  var schArr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cxt.schema;\n  var gen = cxt.gen,\n      parentSchema = cxt.parentSchema,\n      data = cxt.data,\n      keyword = cxt.keyword,\n      it = cxt.it;\n  checkStrictTuple(parentSchema);\n\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n  }\n\n  var valid = gen.name(\"valid\");\n  var len = gen.const(\"len\", (0, codegen_1._)(_templateObject(), data));\n  schArr.forEach(function (sch, i) {\n    if ((0, util_1.alwaysValidSchema)(it, sch)) return;\n    gen.if((0, codegen_1._)(_templateObject2(), len, i), function () {\n      return cxt.subschema({\n        keyword,\n        schemaProp: i,\n        dataProp: i\n      }, valid);\n    });\n    cxt.ok(valid);\n  });\n\n  function checkStrictTuple(sch) {\n    var opts = it.opts,\n        errSchemaPath = it.errSchemaPath;\n    var l = schArr.length;\n    var fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n\n    if (opts.strictTuples && !fullTuple) {\n      var msg = \"\\\"\".concat(keyword, \"\\\" is \").concat(l, \"-tuple, but minItems or maxItems/\").concat(extraItems, \" are not specified or different at path \\\"\").concat(errSchemaPath, \"\\\"\");\n      (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n    }\n  }\n}\n\nexports.validateTuple = validateTuple;\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/items.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n//# sourceMappingURL=items.js.map"]},"metadata":{},"sourceType":"script"}