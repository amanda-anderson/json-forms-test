{"ast":null,"code":"\"use strict\";\n/*\n  The MIT License\n\n  Copyright (c) 2017-2019 EclipseSource Munich\n  https://github.com/eclipsesource/jsonforms\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.not = exports.categorizationHasCategory = exports.hasCategory = exports.isCategory = exports.isCategorization = exports.isNumberFormatControl = exports.isRangeControl = exports.isPrimitiveArrayControl = exports.isArrayObjectControl = exports.isObjectArrayWithNesting = exports.isObjectArrayControl = exports.isObjectArray = exports.isDateTimeControl = exports.isTimeControl = exports.isDateControl = exports.isMultiLineControl = exports.isStringControl = exports.isNumberControl = exports.isIntegerControl = exports.isOneOfEnumControl = exports.isEnumControl = exports.isOneOfControl = exports.isAnyOfControl = exports.isAllOfControl = exports.isObjectControl = exports.isBooleanControl = exports.withIncreasedRank = exports.rankWith = exports.or = exports.and = exports.scopeEndIs = exports.scopeEndsWith = exports.optionIs = exports.uiTypeIs = exports.formatIs = exports.schemaTypeIs = exports.schemaSubPathMatches = exports.schemaMatches = exports.isControl = exports.NOT_APPLICABLE = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar isEmpty_1 = tslib_1.__importDefault(require(\"lodash/isEmpty\"));\n\nvar get_1 = tslib_1.__importDefault(require(\"lodash/get\"));\n\nvar endsWith_1 = tslib_1.__importDefault(require(\"lodash/endsWith\"));\n\nvar last_1 = tslib_1.__importDefault(require(\"lodash/last\"));\n\nvar isArray_1 = tslib_1.__importDefault(require(\"lodash/isArray\"));\n\nvar reduce_1 = tslib_1.__importDefault(require(\"lodash/reduce\"));\n\nvar toPairs_1 = tslib_1.__importDefault(require(\"lodash/toPairs\"));\n\nvar includes_1 = tslib_1.__importDefault(require(\"lodash/includes\"));\n\nvar util_1 = require(\"../util\");\n/**\n * Constant that indicates that a tester is not capable of handling\n * a combination of schema/data.\n * @type {number}\n */\n\n\nexports.NOT_APPLICABLE = -1;\n\nvar isControl = function isControl(uischema) {\n  return !isEmpty_1.default(uischema) && uischema.scope !== undefined;\n};\n\nexports.isControl = isControl;\n/**\n * Only applicable for Controls.\n *\n * This function checks whether the given UI schema is of type Control\n * and if so, resolves the sub-schema referenced by the control and applies\n * the given predicate\n *\n * @param {(JsonSchema) => boolean} predicate the predicate that should be\n *        applied to the resolved sub-schema\n */\n\nvar schemaMatches = function schemaMatches(predicate) {\n  return function (uischema, schema) {\n    if (isEmpty_1.default(uischema) || !exports.isControl(uischema)) {\n      return false;\n    }\n\n    if (isEmpty_1.default(schema)) {\n      return false;\n    }\n\n    var schemaPath = uischema.scope;\n\n    if (isEmpty_1.default(schemaPath)) {\n      return false;\n    }\n\n    var currentDataSchema = schema;\n\n    if (util_1.hasType(schema, 'object')) {\n      currentDataSchema = util_1.resolveSchema(schema, schemaPath);\n    }\n\n    if (currentDataSchema === undefined) {\n      return false;\n    }\n\n    return predicate(currentDataSchema);\n  };\n};\n\nexports.schemaMatches = schemaMatches;\n\nvar schemaSubPathMatches = function schemaSubPathMatches(subPath, predicate) {\n  return function (uischema, schema) {\n    if (isEmpty_1.default(uischema) || !exports.isControl(uischema)) {\n      return false;\n    }\n\n    var schemaPath = uischema.scope;\n    var currentDataSchema = schema;\n\n    if (util_1.hasType(schema, 'object')) {\n      currentDataSchema = util_1.resolveSchema(schema, schemaPath);\n    }\n\n    currentDataSchema = get_1.default(currentDataSchema, subPath);\n\n    if (currentDataSchema === undefined) {\n      return false;\n    }\n\n    return predicate(currentDataSchema);\n  };\n};\n\nexports.schemaSubPathMatches = schemaSubPathMatches;\n/**\n * Only applicable for Controls.\n *\n * This function checks whether the given UI schema is of type Control\n * and if so, resolves the sub-schema referenced by the control and checks\n * whether the type of the sub-schema matches the expected one.\n *\n * @param {string} expectedType the expected type of the resolved sub-schema\n */\n\nvar schemaTypeIs = function schemaTypeIs(expectedType) {\n  return exports.schemaMatches(function (schema) {\n    return !isEmpty_1.default(schema) && util_1.hasType(schema, expectedType);\n  });\n};\n\nexports.schemaTypeIs = schemaTypeIs;\n/**\n * Only applicable for Controls.\n *\n * This function checks whether the given UI schema is of type Control\n * and if so, resolves the sub-schema referenced by the control and checks\n * whether the format of the sub-schema matches the expected one.\n *\n * @param {string} expectedFormat the expected format of the resolved sub-schema\n */\n\nvar formatIs = function formatIs(expectedFormat) {\n  return exports.schemaMatches(function (schema) {\n    return !isEmpty_1.default(schema) && schema.format === expectedFormat && schema.type === 'string';\n  });\n};\n\nexports.formatIs = formatIs;\n/**\n * Checks whether the given UI schema has the expected type.\n *\n * @param {string} expected the expected UI schema type\n */\n\nvar uiTypeIs = function uiTypeIs(expected) {\n  return function (uischema) {\n    return !isEmpty_1.default(uischema) && uischema.type === expected;\n  };\n};\n\nexports.uiTypeIs = uiTypeIs;\n/**\n * Checks whether the given UI schema has an option with the given\n * name and whether it has the expected value. If no options property\n * is set, returns false.\n *\n * @param {string} optionName the name of the option to check\n * @param {any} optionValue the expected value of the option\n */\n\nvar optionIs = function optionIs(optionName, optionValue) {\n  return function (uischema) {\n    if (isEmpty_1.default(uischema)) {\n      return false;\n    }\n\n    var options = uischema.options;\n    return !isEmpty_1.default(options) && options[optionName] === optionValue;\n  };\n};\n\nexports.optionIs = optionIs;\n/**\n * Only applicable for Controls.\n *\n * Checks whether the scope of a control ends with the expected string.\n *\n * @param {string} expected the expected ending of the reference\n */\n\nvar scopeEndsWith = function scopeEndsWith(expected) {\n  return function (uischema) {\n    if (isEmpty_1.default(expected) || !exports.isControl(uischema)) {\n      return false;\n    }\n\n    return endsWith_1.default(uischema.scope, expected);\n  };\n};\n\nexports.scopeEndsWith = scopeEndsWith;\n/**\n * Only applicable for Controls.\n *\n * Checks whether the last segment of the scope matches the expected string.\n *\n * @param {string} expected the expected ending of the reference\n */\n\nvar scopeEndIs = function scopeEndIs(expected) {\n  return function (uischema) {\n    if (isEmpty_1.default(expected) || !exports.isControl(uischema)) {\n      return false;\n    }\n\n    var schemaPath = uischema.scope;\n    return !isEmpty_1.default(schemaPath) && last_1.default(schemaPath.split('/')) === expected;\n  };\n};\n\nexports.scopeEndIs = scopeEndIs;\n/**\n * A tester that allow composing other testers by && them.\n *\n * @param {Array<Tester>} testers the testers to be composed\n */\n\nvar and = function and() {\n  var testers = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    testers[_i] = arguments[_i];\n  }\n\n  return function (uischema, schema) {\n    return testers.reduce(function (acc, tester) {\n      return acc && tester(uischema, schema);\n    }, true);\n  };\n};\n\nexports.and = and;\n/**\n * A tester that allow composing other testers by || them.\n *\n * @param {Array<Tester>} testers the testers to be composed\n */\n\nvar or = function or() {\n  var testers = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    testers[_i] = arguments[_i];\n  }\n\n  return function (uischema, schema) {\n    return testers.reduce(function (acc, tester) {\n      return acc || tester(uischema, schema);\n    }, false);\n  };\n};\n\nexports.or = or;\n/**\n * Create a ranked tester that will associate a number with a given tester, if the\n * latter returns true.\n *\n * @param {number} rank the rank to be returned in case the tester returns true\n * @param {Tester} tester a tester\n */\n\nvar rankWith = function rankWith(rank, tester) {\n  return function (uischema, schema) {\n    if (tester(uischema, schema)) {\n      return rank;\n    }\n\n    return exports.NOT_APPLICABLE;\n  };\n};\n\nexports.rankWith = rankWith;\n\nvar withIncreasedRank = function withIncreasedRank(by, rankedTester) {\n  return function (uischema, schema) {\n    var rank = rankedTester(uischema, schema);\n\n    if (rank === exports.NOT_APPLICABLE) {\n      return exports.NOT_APPLICABLE;\n    }\n\n    return rank + by;\n  };\n};\n\nexports.withIncreasedRank = withIncreasedRank;\n/**\n * Default tester for boolean.\n * @type {RankedTester}\n */\n\nexports.isBooleanControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('boolean')); // TODO: rather check for properties property\n\nexports.isObjectControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('object'));\nexports.isAllOfControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) {\n  return schema.hasOwnProperty('allOf');\n}));\nexports.isAnyOfControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) {\n  return schema.hasOwnProperty('anyOf');\n}));\nexports.isOneOfControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) {\n  return schema.hasOwnProperty('oneOf');\n}));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * has an enum.\n * @type {Tester}\n */\n\nexports.isEnumControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.schemaMatches(function (schema) {\n  return schema.hasOwnProperty('enum');\n}), exports.schemaMatches(function (schema) {\n  return schema.hasOwnProperty('const');\n})));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * has an enum based on oneOf.\n * @type {Tester}\n */\n\nexports.isOneOfEnumControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) {\n  return schema.hasOwnProperty('oneOf') && schema.oneOf.every(function (s) {\n    return s.const !== undefined;\n  });\n}));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is of type integer\n * @type {Tester}\n */\n\nexports.isIntegerControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('integer'));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is of type number\n * @type {Tester}\n */\n\nexports.isNumberControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('number'));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is of type string\n * @type {Tester}\n */\n\nexports.isStringControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('string'));\n/**\n * Tests whether the given UI schema is of type Control and if is has\n * a 'multi' option.\n * @type {Tester}\n */\n\nexports.isMultiLineControl = exports.and(exports.uiTypeIs('Control'), exports.optionIs('multi', true));\n/**\n * Tests whether the given UI schema is of type Control and whether the schema\n * or uischema options has a 'date' format.\n * @type {Tester}\n */\n\nexports.isDateControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.formatIs('date'), exports.optionIs('format', 'date')));\n/**\n * Tests whether the given UI schema is of type Control and whether the schema\n * or the uischema options has a 'time' format.\n * @type {Tester}\n */\n\nexports.isTimeControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.formatIs('time'), exports.optionIs('format', 'time')));\n/**\n * Tests whether the given UI schema is of type Control and whether the schema\n * or the uischema options has a 'date-time' format.\n * @type {Tester}\n */\n\nexports.isDateTimeControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.formatIs('date-time'), exports.optionIs('format', 'date-time')));\n/**\n * Tests whether the given schema is an array of objects.\n * @type {Tester}\n */\n\nexports.isObjectArray = exports.and(exports.schemaMatches(function (schema) {\n  return util_1.hasType(schema, 'array') && !Array.isArray(schema.items);\n} // we don't care about tuples\n), exports.schemaSubPathMatches('items', function (schema) {\n  return util_1.hasType(schema, 'object');\n}));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is an array of objects.\n * @type {Tester}\n */\n\nexports.isObjectArrayControl = exports.and(exports.uiTypeIs('Control'), exports.isObjectArray);\n\nvar traverse = function traverse(any, pred) {\n  if (isArray_1.default(any)) {\n    return reduce_1.default(any, function (acc, el) {\n      return acc || traverse(el, pred);\n    }, false);\n  }\n\n  if (pred(any)) {\n    return true;\n  }\n\n  if (any.items) {\n    return traverse(any.items, pred);\n  }\n\n  if (any.properties) {\n    return reduce_1.default(toPairs_1.default(any.properties), function (acc, _a) {\n      var _key = _a[0],\n          val = _a[1];\n      return acc || traverse(val, pred);\n    }, false);\n  }\n\n  return false;\n};\n\nvar isObjectArrayWithNesting = function isObjectArrayWithNesting(uischema, schema) {\n  if (!exports.uiTypeIs('Control')(uischema, schema)) {\n    return false;\n  }\n\n  var schemaPath = uischema.scope;\n  var resolvedSchema = util_1.resolveSchema(schema, schemaPath);\n  var wantedNestingByType = {\n    object: 2,\n    array: 1\n  };\n\n  if (resolvedSchema !== undefined && resolvedSchema.items !== undefined) {\n    // check if nested arrays\n    if (traverse(resolvedSchema.items, function (val) {\n      if (val === schema) {\n        return false;\n      } // we don't support multiple types\n\n\n      if (typeof val.type !== 'string') {\n        return true;\n      }\n\n      var typeCount = wantedNestingByType[val.type];\n\n      if (typeCount === undefined) {\n        return false;\n      }\n\n      wantedNestingByType[val.type] = typeCount - 1;\n      return wantedNestingByType[val.type] === 0;\n    })) {\n      return true;\n    } // check if uischema options detail is set\n\n\n    if (uischema.options && uischema.options.detail) {\n      if (typeof uischema.options.detail === 'string') {\n        return uischema.options.detail.toUpperCase() !== 'DEFAULT';\n      } else if (typeof uischema.options.detail === 'object' && uischema.options.detail.type) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nexports.isObjectArrayWithNesting = isObjectArrayWithNesting;\n/**\n * Synonym for isObjectArrayControl\n */\n\nexports.isArrayObjectControl = exports.isObjectArrayControl;\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is an array of a primitive type.\n * @type {Tester}\n */\n\nexports.isPrimitiveArrayControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) {\n  return util_1.deriveTypes(schema).length !== 0 && !Array.isArray(schema.items);\n} // we don't care about tuples\n), exports.schemaSubPathMatches('items', function (schema) {\n  var types = util_1.deriveTypes(schema);\n  return types.length === 1 && includes_1.default(['integer', 'number', 'boolean', 'string'], types[0]);\n}));\n/**\n * Tests whether a given UI schema is of type Control,\n * if the schema is of type number or integer and\n * whether the schema defines a numerical range with a default value.\n * @type {Tester}\n */\n\nexports.isRangeControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.schemaTypeIs('number'), exports.schemaTypeIs('integer')), exports.schemaMatches(function (schema) {\n  return schema.hasOwnProperty('maximum') && schema.hasOwnProperty('minimum') && schema.hasOwnProperty('default');\n}), exports.optionIs('slider', true));\n/**\n * Tests whether the given UI schema is of type Control, if the schema\n * is of type string and has option format\n * @type {Tester}\n */\n\nexports.isNumberFormatControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('integer'), exports.optionIs('format', true));\n\nvar isCategorization = function isCategorization(category) {\n  return category.type === 'Categorization';\n};\n\nexports.isCategorization = isCategorization;\n\nvar isCategory = function isCategory(uischema) {\n  return uischema.type === 'Category';\n};\n\nexports.isCategory = isCategory;\n\nvar hasCategory = function hasCategory(categorization) {\n  if (isEmpty_1.default(categorization.elements)) {\n    return false;\n  } // all children of the categorization have to be categories\n\n\n  return categorization.elements.map(function (elem) {\n    return exports.isCategorization(elem) ? exports.hasCategory(elem) : exports.isCategory(elem);\n  }).reduce(function (prev, curr) {\n    return prev && curr;\n  }, true);\n};\n\nexports.hasCategory = hasCategory;\n\nvar categorizationHasCategory = function categorizationHasCategory(uischema) {\n  return exports.hasCategory(uischema);\n};\n\nexports.categorizationHasCategory = categorizationHasCategory;\n\nvar not = function not(tester) {\n  return function (uischema, schema) {\n    return !tester(uischema, schema);\n  };\n};\n\nexports.not = not;","map":{"version":3,"sources":["../../src/testers/testers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n  The MIT License\n\n  Copyright (c) 2017-2019 EclipseSource Munich\n  https://github.com/eclipsesource/jsonforms\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.not = exports.categorizationHasCategory = exports.hasCategory = exports.isCategory = exports.isCategorization = exports.isNumberFormatControl = exports.isRangeControl = exports.isPrimitiveArrayControl = exports.isArrayObjectControl = exports.isObjectArrayWithNesting = exports.isObjectArrayControl = exports.isObjectArray = exports.isDateTimeControl = exports.isTimeControl = exports.isDateControl = exports.isMultiLineControl = exports.isStringControl = exports.isNumberControl = exports.isIntegerControl = exports.isOneOfEnumControl = exports.isEnumControl = exports.isOneOfControl = exports.isAnyOfControl = exports.isAllOfControl = exports.isObjectControl = exports.isBooleanControl = exports.withIncreasedRank = exports.rankWith = exports.or = exports.and = exports.scopeEndIs = exports.scopeEndsWith = exports.optionIs = exports.uiTypeIs = exports.formatIs = exports.schemaTypeIs = exports.schemaSubPathMatches = exports.schemaMatches = exports.isControl = exports.NOT_APPLICABLE = void 0;\nvar tslib_1 = require(\"tslib\");\nvar isEmpty_1 = tslib_1.__importDefault(require(\"lodash/isEmpty\"));\nvar get_1 = tslib_1.__importDefault(require(\"lodash/get\"));\nvar endsWith_1 = tslib_1.__importDefault(require(\"lodash/endsWith\"));\nvar last_1 = tslib_1.__importDefault(require(\"lodash/last\"));\nvar isArray_1 = tslib_1.__importDefault(require(\"lodash/isArray\"));\nvar reduce_1 = tslib_1.__importDefault(require(\"lodash/reduce\"));\nvar toPairs_1 = tslib_1.__importDefault(require(\"lodash/toPairs\"));\nvar includes_1 = tslib_1.__importDefault(require(\"lodash/includes\"));\nvar util_1 = require(\"../util\");\n/**\n * Constant that indicates that a tester is not capable of handling\n * a combination of schema/data.\n * @type {number}\n */\nexports.NOT_APPLICABLE = -1;\nvar isControl = function (uischema) {\n    return !isEmpty_1.default(uischema) && uischema.scope !== undefined;\n};\nexports.isControl = isControl;\n/**\n * Only applicable for Controls.\n *\n * This function checks whether the given UI schema is of type Control\n * and if so, resolves the sub-schema referenced by the control and applies\n * the given predicate\n *\n * @param {(JsonSchema) => boolean} predicate the predicate that should be\n *        applied to the resolved sub-schema\n */\nvar schemaMatches = function (predicate) { return function (uischema, schema) {\n    if (isEmpty_1.default(uischema) || !exports.isControl(uischema)) {\n        return false;\n    }\n    if (isEmpty_1.default(schema)) {\n        return false;\n    }\n    var schemaPath = uischema.scope;\n    if (isEmpty_1.default(schemaPath)) {\n        return false;\n    }\n    var currentDataSchema = schema;\n    if (util_1.hasType(schema, 'object')) {\n        currentDataSchema = util_1.resolveSchema(schema, schemaPath);\n    }\n    if (currentDataSchema === undefined) {\n        return false;\n    }\n    return predicate(currentDataSchema);\n}; };\nexports.schemaMatches = schemaMatches;\nvar schemaSubPathMatches = function (subPath, predicate) { return function (uischema, schema) {\n    if (isEmpty_1.default(uischema) || !exports.isControl(uischema)) {\n        return false;\n    }\n    var schemaPath = uischema.scope;\n    var currentDataSchema = schema;\n    if (util_1.hasType(schema, 'object')) {\n        currentDataSchema = util_1.resolveSchema(schema, schemaPath);\n    }\n    currentDataSchema = get_1.default(currentDataSchema, subPath);\n    if (currentDataSchema === undefined) {\n        return false;\n    }\n    return predicate(currentDataSchema);\n}; };\nexports.schemaSubPathMatches = schemaSubPathMatches;\n/**\n * Only applicable for Controls.\n *\n * This function checks whether the given UI schema is of type Control\n * and if so, resolves the sub-schema referenced by the control and checks\n * whether the type of the sub-schema matches the expected one.\n *\n * @param {string} expectedType the expected type of the resolved sub-schema\n */\nvar schemaTypeIs = function (expectedType) {\n    return exports.schemaMatches(function (schema) { return !isEmpty_1.default(schema) && util_1.hasType(schema, expectedType); });\n};\nexports.schemaTypeIs = schemaTypeIs;\n/**\n * Only applicable for Controls.\n *\n * This function checks whether the given UI schema is of type Control\n * and if so, resolves the sub-schema referenced by the control and checks\n * whether the format of the sub-schema matches the expected one.\n *\n * @param {string} expectedFormat the expected format of the resolved sub-schema\n */\nvar formatIs = function (expectedFormat) {\n    return exports.schemaMatches(function (schema) {\n        return !isEmpty_1.default(schema) &&\n            schema.format === expectedFormat &&\n            schema.type === 'string';\n    });\n};\nexports.formatIs = formatIs;\n/**\n * Checks whether the given UI schema has the expected type.\n *\n * @param {string} expected the expected UI schema type\n */\nvar uiTypeIs = function (expected) { return function (uischema) { return !isEmpty_1.default(uischema) && uischema.type === expected; }; };\nexports.uiTypeIs = uiTypeIs;\n/**\n * Checks whether the given UI schema has an option with the given\n * name and whether it has the expected value. If no options property\n * is set, returns false.\n *\n * @param {string} optionName the name of the option to check\n * @param {any} optionValue the expected value of the option\n */\nvar optionIs = function (optionName, optionValue) { return function (uischema) {\n    if (isEmpty_1.default(uischema)) {\n        return false;\n    }\n    var options = uischema.options;\n    return !isEmpty_1.default(options) && options[optionName] === optionValue;\n}; };\nexports.optionIs = optionIs;\n/**\n * Only applicable for Controls.\n *\n * Checks whether the scope of a control ends with the expected string.\n *\n * @param {string} expected the expected ending of the reference\n */\nvar scopeEndsWith = function (expected) { return function (uischema) {\n    if (isEmpty_1.default(expected) || !exports.isControl(uischema)) {\n        return false;\n    }\n    return endsWith_1.default(uischema.scope, expected);\n}; };\nexports.scopeEndsWith = scopeEndsWith;\n/**\n * Only applicable for Controls.\n *\n * Checks whether the last segment of the scope matches the expected string.\n *\n * @param {string} expected the expected ending of the reference\n */\nvar scopeEndIs = function (expected) { return function (uischema) {\n    if (isEmpty_1.default(expected) || !exports.isControl(uischema)) {\n        return false;\n    }\n    var schemaPath = uischema.scope;\n    return !isEmpty_1.default(schemaPath) && last_1.default(schemaPath.split('/')) === expected;\n}; };\nexports.scopeEndIs = scopeEndIs;\n/**\n * A tester that allow composing other testers by && them.\n *\n * @param {Array<Tester>} testers the testers to be composed\n */\nvar and = function () {\n    var testers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        testers[_i] = arguments[_i];\n    }\n    return function (uischema, schema) { return testers.reduce(function (acc, tester) { return acc && tester(uischema, schema); }, true); };\n};\nexports.and = and;\n/**\n * A tester that allow composing other testers by || them.\n *\n * @param {Array<Tester>} testers the testers to be composed\n */\nvar or = function () {\n    var testers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        testers[_i] = arguments[_i];\n    }\n    return function (uischema, schema) { return testers.reduce(function (acc, tester) { return acc || tester(uischema, schema); }, false); };\n};\nexports.or = or;\n/**\n * Create a ranked tester that will associate a number with a given tester, if the\n * latter returns true.\n *\n * @param {number} rank the rank to be returned in case the tester returns true\n * @param {Tester} tester a tester\n */\nvar rankWith = function (rank, tester) { return function (uischema, schema) {\n    if (tester(uischema, schema)) {\n        return rank;\n    }\n    return exports.NOT_APPLICABLE;\n}; };\nexports.rankWith = rankWith;\nvar withIncreasedRank = function (by, rankedTester) { return function (uischema, schema) {\n    var rank = rankedTester(uischema, schema);\n    if (rank === exports.NOT_APPLICABLE) {\n        return exports.NOT_APPLICABLE;\n    }\n    return rank + by;\n}; };\nexports.withIncreasedRank = withIncreasedRank;\n/**\n * Default tester for boolean.\n * @type {RankedTester}\n */\nexports.isBooleanControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('boolean'));\n// TODO: rather check for properties property\nexports.isObjectControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('object'));\nexports.isAllOfControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) { return schema.hasOwnProperty('allOf'); }));\nexports.isAnyOfControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) { return schema.hasOwnProperty('anyOf'); }));\nexports.isOneOfControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) { return schema.hasOwnProperty('oneOf'); }));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * has an enum.\n * @type {Tester}\n */\nexports.isEnumControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.schemaMatches(function (schema) { return schema.hasOwnProperty('enum'); }), exports.schemaMatches(function (schema) { return schema.hasOwnProperty('const'); })));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * has an enum based on oneOf.\n * @type {Tester}\n */\nexports.isOneOfEnumControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) {\n    return schema.hasOwnProperty('oneOf') &&\n        schema.oneOf.every(function (s) { return s.const !== undefined; });\n}));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is of type integer\n * @type {Tester}\n */\nexports.isIntegerControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('integer'));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is of type number\n * @type {Tester}\n */\nexports.isNumberControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('number'));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is of type string\n * @type {Tester}\n */\nexports.isStringControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('string'));\n/**\n * Tests whether the given UI schema is of type Control and if is has\n * a 'multi' option.\n * @type {Tester}\n */\nexports.isMultiLineControl = exports.and(exports.uiTypeIs('Control'), exports.optionIs('multi', true));\n/**\n * Tests whether the given UI schema is of type Control and whether the schema\n * or uischema options has a 'date' format.\n * @type {Tester}\n */\nexports.isDateControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.formatIs('date'), exports.optionIs('format', 'date')));\n/**\n * Tests whether the given UI schema is of type Control and whether the schema\n * or the uischema options has a 'time' format.\n * @type {Tester}\n */\nexports.isTimeControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.formatIs('time'), exports.optionIs('format', 'time')));\n/**\n * Tests whether the given UI schema is of type Control and whether the schema\n * or the uischema options has a 'date-time' format.\n * @type {Tester}\n */\nexports.isDateTimeControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.formatIs('date-time'), exports.optionIs('format', 'date-time')));\n/**\n * Tests whether the given schema is an array of objects.\n * @type {Tester}\n */\nexports.isObjectArray = exports.and(exports.schemaMatches(function (schema) { return util_1.hasType(schema, 'array') && !Array.isArray(schema.items); } // we don't care about tuples\n), exports.schemaSubPathMatches('items', function (schema) { return util_1.hasType(schema, 'object'); }));\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is an array of objects.\n * @type {Tester}\n */\nexports.isObjectArrayControl = exports.and(exports.uiTypeIs('Control'), exports.isObjectArray);\nvar traverse = function (any, pred) {\n    if (isArray_1.default(any)) {\n        return reduce_1.default(any, function (acc, el) { return acc || traverse(el, pred); }, false);\n    }\n    if (pred(any)) {\n        return true;\n    }\n    if (any.items) {\n        return traverse(any.items, pred);\n    }\n    if (any.properties) {\n        return reduce_1.default(toPairs_1.default(any.properties), function (acc, _a) {\n            var _key = _a[0], val = _a[1];\n            return acc || traverse(val, pred);\n        }, false);\n    }\n    return false;\n};\nvar isObjectArrayWithNesting = function (uischema, schema) {\n    if (!exports.uiTypeIs('Control')(uischema, schema)) {\n        return false;\n    }\n    var schemaPath = uischema.scope;\n    var resolvedSchema = util_1.resolveSchema(schema, schemaPath);\n    var wantedNestingByType = {\n        object: 2,\n        array: 1\n    };\n    if (resolvedSchema !== undefined && resolvedSchema.items !== undefined) {\n        // check if nested arrays\n        if (traverse(resolvedSchema.items, function (val) {\n            if (val === schema) {\n                return false;\n            }\n            // we don't support multiple types\n            if (typeof val.type !== 'string') {\n                return true;\n            }\n            var typeCount = wantedNestingByType[val.type];\n            if (typeCount === undefined) {\n                return false;\n            }\n            wantedNestingByType[val.type] = typeCount - 1;\n            return wantedNestingByType[val.type] === 0;\n        })) {\n            return true;\n        }\n        // check if uischema options detail is set\n        if (uischema.options && uischema.options.detail) {\n            if (typeof uischema.options.detail === 'string') {\n                return uischema.options.detail.toUpperCase() !== 'DEFAULT';\n            }\n            else if (typeof uischema.options.detail === 'object' &&\n                uischema.options.detail.type) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\nexports.isObjectArrayWithNesting = isObjectArrayWithNesting;\n/**\n * Synonym for isObjectArrayControl\n */\nexports.isArrayObjectControl = exports.isObjectArrayControl;\n/**\n * Tests whether the given UI schema is of type Control and if the schema\n * is an array of a primitive type.\n * @type {Tester}\n */\nexports.isPrimitiveArrayControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(function (schema) { return util_1.deriveTypes(schema).length !== 0 && !Array.isArray(schema.items); } // we don't care about tuples\n), exports.schemaSubPathMatches('items', function (schema) {\n    var types = util_1.deriveTypes(schema);\n    return (types.length === 1 &&\n        includes_1.default(['integer', 'number', 'boolean', 'string'], types[0]));\n}));\n/**\n * Tests whether a given UI schema is of type Control,\n * if the schema is of type number or integer and\n * whether the schema defines a numerical range with a default value.\n * @type {Tester}\n */\nexports.isRangeControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.schemaTypeIs('number'), exports.schemaTypeIs('integer')), exports.schemaMatches(function (schema) {\n    return schema.hasOwnProperty('maximum') &&\n        schema.hasOwnProperty('minimum') &&\n        schema.hasOwnProperty('default');\n}), exports.optionIs('slider', true));\n/**\n * Tests whether the given UI schema is of type Control, if the schema\n * is of type string and has option format\n * @type {Tester}\n */\nexports.isNumberFormatControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('integer'), exports.optionIs('format', true));\nvar isCategorization = function (category) { return category.type === 'Categorization'; };\nexports.isCategorization = isCategorization;\nvar isCategory = function (uischema) {\n    return uischema.type === 'Category';\n};\nexports.isCategory = isCategory;\nvar hasCategory = function (categorization) {\n    if (isEmpty_1.default(categorization.elements)) {\n        return false;\n    }\n    // all children of the categorization have to be categories\n    return categorization.elements\n        .map(function (elem) {\n        return exports.isCategorization(elem) ? exports.hasCategory(elem) : exports.isCategory(elem);\n    })\n        .reduce(function (prev, curr) { return prev && curr; }, true);\n};\nexports.hasCategory = hasCategory;\nvar categorizationHasCategory = function (uischema) {\n    return exports.hasCategory(uischema);\n};\nexports.categorizationHasCategory = categorizationHasCategory;\nvar not = function (tester) { return function (uischema, schema) { return !tester(uischema, schema); }; };\nexports.not = not;\n//# sourceMappingURL=testers.js.map"]},"metadata":{},"sourceType":"script"}