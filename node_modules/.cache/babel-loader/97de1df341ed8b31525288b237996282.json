{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\n\nvar util_1 = require(\"./util\");\n\nvar equal = require(\"fast-deep-equal\");\n\nvar traverse = require(\"json-schema-traverse\"); // TODO refactor to use keyword definitions\n\n\nvar SIMPLE_INLINED = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\n\nfunction inlineRef(schema) {\n  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (typeof schema == \"boolean\") return true;\n  if (limit === true) return !hasRef(schema);\n  if (!limit) return false;\n  return countKeys(schema) <= limit;\n}\n\nexports.inlineRef = inlineRef;\nvar REF_KEYWORDS = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\n\nfunction hasRef(schema) {\n  for (var key in schema) {\n    if (REF_KEYWORDS.has(key)) return true;\n    var sch = schema[key];\n    if (Array.isArray(sch) && sch.some(hasRef)) return true;\n    if (typeof sch == \"object\" && hasRef(sch)) return true;\n  }\n\n  return false;\n}\n\nfunction countKeys(schema) {\n  var count = 0;\n\n  for (var key in schema) {\n    if (key === \"$ref\") return Infinity;\n    count++;\n    if (SIMPLE_INLINED.has(key)) continue;\n\n    if (typeof schema[key] == \"object\") {\n      (0, util_1.eachItem)(schema[key], function (sch) {\n        return count += countKeys(sch);\n      });\n    }\n\n    if (count === Infinity) return Infinity;\n  }\n\n  return count;\n}\n\nfunction getFullPath(resolver) {\n  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var normalize = arguments.length > 2 ? arguments[2] : undefined;\n  if (normalize !== false) id = normalizeId(id);\n  var p = resolver.parse(id);\n  return _getFullPath(resolver, p);\n}\n\nexports.getFullPath = getFullPath;\n\nfunction _getFullPath(resolver, p) {\n  var serialized = resolver.serialize(p);\n  return serialized.split(\"#\")[0] + \"#\";\n}\n\nexports._getFullPath = _getFullPath;\nvar TRAILING_SLASH_HASH = /#\\/?$/;\n\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\n\nexports.normalizeId = normalizeId;\n\nfunction resolveUrl(resolver, baseId, id) {\n  id = normalizeId(id);\n  return resolver.resolve(baseId, id);\n}\n\nexports.resolveUrl = resolveUrl;\nvar ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\n\nfunction getSchemaRefs(schema, baseId) {\n  var _this = this;\n\n  if (typeof schema == \"boolean\") return {};\n  var _this$opts = this.opts,\n      schemaId = _this$opts.schemaId,\n      uriResolver = _this$opts.uriResolver;\n  var schId = normalizeId(schema[schemaId] || baseId);\n  var baseIds = {\n    \"\": schId\n  };\n  var pathPrefix = getFullPath(uriResolver, schId, false);\n  var localRefs = {};\n  var schemaRefs = new Set();\n  traverse(schema, {\n    allKeys: true\n  }, function (sch, jsonPtr, _, parentJsonPtr) {\n    if (parentJsonPtr === undefined) return;\n    var fullPath = pathPrefix + jsonPtr;\n    var baseId = baseIds[parentJsonPtr];\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(_this, sch[schemaId]);\n    addAnchor.call(_this, sch.$anchor);\n    addAnchor.call(_this, sch.$dynamicAnchor);\n    baseIds[jsonPtr] = baseId;\n\n    function addRef(ref) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      var _resolve = this.opts.uriResolver.resolve;\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n      if (schemaRefs.has(ref)) throw ambiguos(ref);\n      schemaRefs.add(ref);\n      var schOrRef = this.refs[ref];\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref);\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref);\n          localRefs[ref] = sch;\n        } else {\n          this.refs[ref] = fullPath;\n        }\n      }\n\n      return ref;\n    }\n\n    function addAnchor(anchor) {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(\"invalid anchor \\\"\".concat(anchor, \"\\\"\"));\n        addRef.call(this, \"#\".concat(anchor));\n      }\n    }\n  });\n  return localRefs;\n\n  function checkAmbiguosRef(sch1, sch2, ref) {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);\n  }\n\n  function ambiguos(ref) {\n    return new Error(\"reference \\\"\".concat(ref, \"\\\" resolves to more than one schema\"));\n  }\n}\n\nexports.getSchemaRefs = getSchemaRefs;","map":{"version":3,"sources":["../../lib/compile/resolve.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let baseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            baseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = baseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map"]},"metadata":{},"sourceType":"script"}