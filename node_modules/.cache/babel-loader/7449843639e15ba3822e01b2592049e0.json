{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteral([\"\", \" === \", \"\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"typeof \", \" == \\\"string\\\"\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\", \"\", \"\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"{error: \", \", tag: \", \", tagValue: \", \"}\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar types_1 = require(\"../discriminator/types\");\n\nvar compile_1 = require(\"../../compile\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: function message(_ref) {\n    var _ref$params = _ref.params,\n        discrError = _ref$params.discrError,\n        tagName = _ref$params.tagName;\n    return discrError === types_1.DiscrError.Tag ? \"tag \\\"\".concat(tagName, \"\\\" must be string\") : \"value of tag \\\"\".concat(tagName, \"\\\" must be in oneOf\");\n  },\n  params: function params(_ref2) {\n    var _ref2$params = _ref2.params,\n        discrError = _ref2$params.discrError,\n        tag = _ref2$params.tag,\n        tagName = _ref2$params.tagName;\n    return (0, codegen_1._)(_templateObject(), discrError, tagName, tag);\n  }\n};\nvar def = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n\n  code(cxt) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        schema = cxt.schema,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    var oneOf = parentSchema.oneOf;\n\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\");\n    }\n\n    var tagName = schema.propertyName;\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\");\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n    var valid = gen.let(\"valid\", false);\n    var tag = gen.const(\"tag\", (0, codegen_1._)(_templateObject2(), data, (0, codegen_1.getProperty)(tagName)));\n    gen.if((0, codegen_1._)(_templateObject3(), tag), function () {\n      return validateMapping();\n    }, function () {\n      return cxt.error(false, {\n        discrError: types_1.DiscrError.Tag,\n        tag,\n        tagName\n      });\n    });\n    cxt.ok(valid);\n\n    function validateMapping() {\n      var mapping = getMapping();\n      gen.if(false);\n\n      for (var tagValue in mapping) {\n        gen.elseIf((0, codegen_1._)(_templateObject4(), tag, tagValue));\n        gen.assign(valid, applyTagSchema(mapping[tagValue]));\n      }\n\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag,\n        tagName\n      });\n      gen.endIf();\n    }\n\n    function applyTagSchema(schemaProp) {\n      var _valid = gen.name(\"valid\");\n\n      var schCxt = cxt.subschema({\n        keyword: \"oneOf\",\n        schemaProp\n      }, _valid);\n      cxt.mergeEvaluated(schCxt, codegen_1.Name);\n      return _valid;\n    }\n\n    function getMapping() {\n      var _a;\n\n      var oneOfMapping = {};\n      var topRequired = hasRequired(parentSchema);\n      var tagRequired = true;\n\n      for (var i = 0; i < oneOf.length; i++) {\n        var sch = oneOf[i];\n\n        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n          sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n          if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;\n        }\n\n        var propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n\n        if (typeof propSch != \"object\") {\n          throw new Error(\"discriminator: oneOf subschemas (or referenced schemas) must have \\\"properties/\".concat(tagName, \"\\\"\"));\n        }\n\n        tagRequired = tagRequired && (topRequired || hasRequired(sch));\n        addMappings(propSch, i);\n      }\n\n      if (!tagRequired) throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" must be required\"));\n      return oneOfMapping;\n\n      function hasRequired(_ref3) {\n        var required = _ref3.required;\n        return Array.isArray(required) && required.includes(tagName);\n      }\n\n      function addMappings(sch, i) {\n        if (sch.const) {\n          addMapping(sch.const, i);\n        } else if (sch.enum) {\n          var _iterator = _createForOfIteratorHelper(sch.enum),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var tagValue = _step.value;\n              addMapping(tagValue, i);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          throw new Error(\"discriminator: \\\"properties/\".concat(tagName, \"\\\" must have \\\"const\\\" or \\\"enum\\\"\"));\n        }\n      }\n\n      function addMapping(tagValue, i) {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" values must be unique strings\"));\n        }\n\n        oneOfMapping[tagValue] = i;\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/discriminator/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}