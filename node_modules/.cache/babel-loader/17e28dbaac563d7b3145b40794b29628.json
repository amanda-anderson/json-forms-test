{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject39() {\n  var data = _taggedTemplateLiteral([\"\", \" && \", \"\"]);\n\n  _templateObject39 = function _templateObject39() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject38() {\n  var data = _taggedTemplateLiteral([\"\", \"\", \"\"]);\n\n  _templateObject38 = function _templateObject38() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject37() {\n  var data = _taggedTemplateLiteral([\"!\", \"(\", \")\"]);\n\n  _templateObject37 = function _templateObject37() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject36() {\n  var data = _taggedTemplateLiteral([\"\", \"\"]);\n\n  _templateObject36 = function _templateObject36() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject35() {\n  var data = _taggedTemplateLiteral([\"\", \" === undefined\"]);\n\n  _templateObject35 = function _templateObject35() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject34() {\n  var data = _taggedTemplateLiteral([\"\", \" !== undefined && (\", \")\"]);\n\n  _templateObject34 = function _templateObject34() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject33() {\n  var data = _taggedTemplateLiteral([\"\", \" === \", \"\"]);\n\n  _templateObject33 = function _templateObject33() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject32() {\n  var data = _taggedTemplateLiteral([\"\", \".items\"]);\n\n  _templateObject32 = function _templateObject32() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject31() {\n  var data = _taggedTemplateLiteral([\"\", \".props\"]);\n\n  _templateObject31 = function _templateObject31() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject30() {\n  var data = _taggedTemplateLiteral([\"\", \" === 0\"]);\n\n  _templateObject30 = function _templateObject30() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject29() {\n  var data = _taggedTemplateLiteral([\"\", \".errors\"]);\n\n  _templateObject29 = function _templateObject29() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject28() {\n  var data = _taggedTemplateLiteral([\"new \", \"(\", \")\"]);\n\n  _templateObject28 = function _templateObject28() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject27() {\n  var data = _taggedTemplateLiteral([\"\", \" === 0\"]);\n\n  _templateObject27 = function _templateObject27() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject26() {\n  var data = _taggedTemplateLiteral([\"\", \".opts.$comment(\", \", \", \", \", \".schema)\"]);\n\n  _templateObject26 = function _templateObject26() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject25() {\n  var data = _taggedTemplateLiteral([\"\", \"/$comment\"]);\n\n  _templateObject25 = function _templateObject25() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject24() {\n  var data = _taggedTemplateLiteral([\"\", \".logger.log(\", \")\"]);\n\n  _templateObject24 = function _templateObject24() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject23() {\n  var data = _taggedTemplateLiteral([\"\", \" === \", \"\"]);\n\n  _templateObject23 = function _templateObject23() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject22() {\n  var data = _taggedTemplateLiteral([\"/*# sourceURL=\", \" */\"]);\n\n  _templateObject22 = function _templateObject22() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject21() {\n  var data = _taggedTemplateLiteral([\"undefined\"]);\n\n  _templateObject21 = function _templateObject21() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject20() {\n  var data = _taggedTemplateLiteral([\"\", \".items\"]);\n\n  _templateObject20 = function _templateObject20() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject19() {\n  var data = _taggedTemplateLiteral([\"\", \".dynamicItems\"]);\n\n  _templateObject19 = function _templateObject19() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject18() {\n  var data = _taggedTemplateLiteral([\"undefined\"]);\n\n  _templateObject18 = function _templateObject18() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject17() {\n  var data = _taggedTemplateLiteral([\"\", \".props\"]);\n\n  _templateObject17 = function _templateObject17() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject16() {\n  var data = _taggedTemplateLiteral([\"\", \".dynamicProps\"]);\n\n  _templateObject16 = function _templateObject16() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject15() {\n  var data = _taggedTemplateLiteral([\"\", \".evaluated\"]);\n\n  _templateObject15 = function _templateObject15() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject14() {\n  var data = _taggedTemplateLiteral([\"{}\"]);\n\n  _templateObject14 = function _templateObject14() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject13() {\n  var data = _taggedTemplateLiteral([\"undefined\"]);\n\n  _templateObject13 = function _templateObject13() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject12() {\n  var data = _taggedTemplateLiteral([\"undefined\"]);\n\n  _templateObject12 = function _templateObject12() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject11() {\n  var data = _taggedTemplateLiteral([\"\\\"\\\"\"]);\n\n  _templateObject11 = function _templateObject11() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject10() {\n  var data = _taggedTemplateLiteral([\"\", \".\", \"\"]);\n\n  _templateObject10 = function _templateObject10() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject9() {\n  var data = _taggedTemplateLiteral([\"\", \".\", \"\"]);\n\n  _templateObject9 = function _templateObject9() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject8() {\n  var data = _taggedTemplateLiteral([\"\", \".\", \"\"]);\n\n  _templateObject8 = function _templateObject8() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject7() {\n  var data = _taggedTemplateLiteral([\"\", \".\", \"\"]);\n\n  _templateObject7 = function _templateObject7() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject6() {\n  var data = _taggedTemplateLiteral([\"\", \".\", \"\"]);\n\n  _templateObject6 = function _templateObject6() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject5() {\n  var data = _taggedTemplateLiteral([\", \", \"={}\"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteral([\"{\", \"=\\\"\\\", \", \", \", \", \", \"=\", \"\", \"}={}\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\", \", \", \"\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\\\"use strict\\\"; \", \"\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\", \", \", \"\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\n\nvar boolSchema_1 = require(\"./boolSchema\");\n\nvar dataType_1 = require(\"./dataType\");\n\nvar applicability_1 = require(\"./applicability\");\n\nvar dataType_2 = require(\"./dataType\");\n\nvar defaults_1 = require(\"./defaults\");\n\nvar keyword_1 = require(\"./keyword\");\n\nvar subschema_1 = require(\"./subschema\");\n\nvar codegen_1 = require(\"../codegen\");\n\nvar names_1 = require(\"../names\");\n\nvar resolve_1 = require(\"../resolve\");\n\nvar util_1 = require(\"../util\");\n\nvar errors_1 = require(\"../errors\"); // schema compilation - generates validation function, subschemaCode (below) is used for subschemas\n\n\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n\n  validateFunction(it, function () {\n    return (0, boolSchema_1.topBoolOrEmptySchema)(it);\n  });\n}\n\nexports.validateFunctionCode = validateFunctionCode;\n\nfunction validateFunction(_ref, body) {\n  var gen = _ref.gen,\n      validateName = _ref.validateName,\n      schema = _ref.schema,\n      schemaEnv = _ref.schemaEnv,\n      opts = _ref.opts;\n\n  if (opts.code.es5) {\n    gen.func(validateName, (0, codegen_1._)(_templateObject(), names_1.default.data, names_1.default.valCxt), schemaEnv.$async, function () {\n      gen.code((0, codegen_1._)(_templateObject2(), funcSourceUrl(schema, opts)));\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, (0, codegen_1._)(_templateObject3(), names_1.default.data, destructureValCxt(opts)), schemaEnv.$async, function () {\n      return gen.code(funcSourceUrl(schema, opts)).code(body);\n    });\n  }\n}\n\nfunction destructureValCxt(opts) {\n  return (0, codegen_1._)(_templateObject4(), names_1.default.instancePath, names_1.default.parentData, names_1.default.parentDataProperty, names_1.default.rootData, names_1.default.data, opts.dynamicRef ? (0, codegen_1._)(_templateObject5(), names_1.default.dynamicAnchors) : codegen_1.nil);\n}\n\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, function () {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)(_templateObject6(), names_1.default.valCxt, names_1.default.instancePath));\n    gen.var(names_1.default.parentData, (0, codegen_1._)(_templateObject7(), names_1.default.valCxt, names_1.default.parentData));\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)(_templateObject8(), names_1.default.valCxt, names_1.default.parentDataProperty));\n    gen.var(names_1.default.rootData, (0, codegen_1._)(_templateObject9(), names_1.default.valCxt, names_1.default.rootData));\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)(_templateObject10(), names_1.default.valCxt, names_1.default.dynamicAnchors));\n  }, function () {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)(_templateObject11()));\n    gen.var(names_1.default.parentData, (0, codegen_1._)(_templateObject12()));\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)(_templateObject13()));\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)(_templateObject14()));\n  });\n}\n\nfunction topSchemaObjCode(it) {\n  var schema = it.schema,\n      opts = it.opts,\n      gen = it.gen;\n  validateFunction(it, function () {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\n\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  var gen = it.gen,\n      validateName = it.validateName;\n  it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)(_templateObject15(), validateName));\n  gen.if((0, codegen_1._)(_templateObject16(), it.evaluated), function () {\n    return gen.assign((0, codegen_1._)(_templateObject17(), it.evaluated), (0, codegen_1._)(_templateObject18()));\n  });\n  gen.if((0, codegen_1._)(_templateObject19(), it.evaluated), function () {\n    return gen.assign((0, codegen_1._)(_templateObject20(), it.evaluated), (0, codegen_1._)(_templateObject21()));\n  });\n}\n\nfunction funcSourceUrl(schema, opts) {\n  var schId = typeof schema == \"object\" && schema[opts.schemaId];\n  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)(_templateObject22(), schId) : codegen_1.nil;\n} // schema compilation - this function is used recursively to generate code for sub-schemas\n\n\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n\n  (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\n\nfunction schemaCxtHasRules(_ref2) {\n  var schema = _ref2.schema,\n      self = _ref2.self;\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (var key in schema) {\n    if (self.RULES.all[key]) return true;\n  }\n\n  return false;\n}\n\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\n\nfunction subSchemaObjCode(it, valid) {\n  var schema = it.schema,\n      gen = it.gen,\n      opts = it.opts;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  var errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount); // TODO var\n\n  gen.var(valid, (0, codegen_1._)(_templateObject23(), errsCount, names_1.default.errors));\n}\n\nfunction checkKeywords(it) {\n  (0, util_1.checkUnknownRules)(it);\n  checkRefsAndKeywords(it);\n}\n\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  var types = (0, dataType_1.getSchemaTypes)(it.schema);\n  var checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\n\nfunction checkRefsAndKeywords(it) {\n  var schema = it.schema,\n      errSchemaPath = it.errSchemaPath,\n      opts = it.opts,\n      self = it.self;\n\n  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n    self.logger.warn(\"$ref: keywords ignored in schema at path \\\"\".concat(errSchemaPath, \"\\\"\"));\n  }\n}\n\nfunction checkNoDefault(it) {\n  var schema = it.schema,\n      opts = it.opts;\n\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n  }\n}\n\nfunction updateContext(it) {\n  var schId = it.schema[it.opts.schemaId];\n  if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\n\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\n\nfunction commentKeyword(_ref3) {\n  var gen = _ref3.gen,\n      schemaEnv = _ref3.schemaEnv,\n      schema = _ref3.schema,\n      errSchemaPath = _ref3.errSchemaPath,\n      opts = _ref3.opts;\n  var msg = schema.$comment;\n\n  if (opts.$comment === true) {\n    gen.code((0, codegen_1._)(_templateObject24(), names_1.default.self, msg));\n  } else if (typeof opts.$comment == \"function\") {\n    var schemaPath = (0, codegen_1.str)(_templateObject25(), errSchemaPath);\n    var rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code((0, codegen_1._)(_templateObject26(), names_1.default.self, msg, schemaPath, rootName));\n  }\n}\n\nfunction returnResults(it) {\n  var gen = it.gen,\n      schemaEnv = it.schemaEnv,\n      validateName = it.validateName,\n      ValidationError = it.ValidationError,\n      opts = it.opts;\n\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if((0, codegen_1._)(_templateObject27(), names_1.default.errors), function () {\n      return gen.return(names_1.default.data);\n    }, function () {\n      return gen.throw((0, codegen_1._)(_templateObject28(), ValidationError, names_1.default.vErrors));\n    });\n  } else {\n    gen.assign((0, codegen_1._)(_templateObject29(), validateName), names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return((0, codegen_1._)(_templateObject30(), names_1.default.errors));\n  }\n}\n\nfunction assignEvaluated(_ref4) {\n  var gen = _ref4.gen,\n      evaluated = _ref4.evaluated,\n      props = _ref4.props,\n      items = _ref4.items;\n  if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject31(), evaluated), props);\n  if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject32(), evaluated), items);\n}\n\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  var gen = it.gen,\n      schema = it.schema,\n      data = it.data,\n      allErrors = it.allErrors,\n      opts = it.opts,\n      self = it.self;\n  var RULES = self.RULES;\n\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n    gen.block(function () {\n      return keywordCode(it, \"$ref\", RULES.all.$ref.definition);\n    }); // TODO typecast\n\n    return;\n  }\n\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(function () {\n    var _iterator = _createForOfIteratorHelper(RULES.rules),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var group = _step.value;\n        groupKeywords(group);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    groupKeywords(RULES.post);\n  });\n\n  function groupKeywords(group) {\n    if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;\n\n    if (group.type) {\n      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        (0, dataType_2.reportTypeError)(it);\n      }\n\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    } // TODO make it \"ok\" call?\n\n\n    if (!allErrors) gen.if((0, codegen_1._)(_templateObject33(), names_1.default.errors, errsCount || 0));\n  }\n}\n\nfunction iterateKeywords(it, group) {\n  var gen = it.gen,\n      schema = it.schema,\n      useDefaults = it.opts.useDefaults;\n  if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);\n  gen.block(function () {\n    var _iterator2 = _createForOfIteratorHelper(group.rules),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var rule = _step2.value;\n\n        if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n          keywordCode(it, rule.keyword, rule.definition, group.type);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  });\n}\n\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\n\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n\n  types.forEach(function (t) {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, \"type \\\"\".concat(t, \"\\\" not allowed by context \\\"\").concat(it.dataTypes.join(\",\"), \"\\\"\"));\n    }\n  });\n  it.dataTypes = it.dataTypes.filter(function (t) {\n    return includesType(types, t);\n  });\n}\n\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\n\nfunction checkKeywordTypes(it, ts) {\n  var rules = it.self.RULES.all;\n\n  for (var keyword in rules) {\n    var rule = rules[keyword];\n\n    if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n      var type = rule.definition.type;\n\n      if (type.length && !type.some(function (t) {\n        return hasApplicableType(ts, t);\n      })) {\n        strictTypesError(it, \"missing type \\\"\".concat(type.join(\",\"), \"\\\" for keyword \\\"\").concat(keyword, \"\\\"\"));\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\n\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\n\nfunction strictTypesError(it, msg) {\n  var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += \" at \\\"\".concat(schemaPath, \"\\\" (strictTypes)\");\n  (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\n\nvar KeywordCxt = /*#__PURE__*/function () {\n  function KeywordCxt(it, def, keyword) {\n    _classCallCheck(this, KeywordCxt);\n\n    (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n\n      if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(\"\".concat(keyword, \" value must be \").concat(JSON.stringify(def.schemaType)));\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n\n  _createClass(KeywordCxt, [{\n    key: \"result\",\n    value: function result(condition, successAction, failAction) {\n      this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n  }, {\n    key: \"failResult\",\n    value: function failResult(condition, successAction, failAction) {\n      this.gen.if(condition);\n      if (failAction) failAction();else this.error();\n\n      if (successAction) {\n        this.gen.else();\n        successAction();\n        if (this.allErrors) this.gen.endIf();\n      } else {\n        if (this.allErrors) this.gen.endIf();else this.gen.else();\n      }\n    }\n  }, {\n    key: \"pass\",\n    value: function pass(condition, failAction) {\n      this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(condition) {\n      if (condition === undefined) {\n        this.error();\n        if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n\n        return;\n      }\n\n      this.gen.if(condition);\n      this.error();\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }, {\n    key: \"fail$data\",\n    value: function fail$data(condition) {\n      if (!this.$data) return this.fail(condition);\n      var schemaCode = this.schemaCode;\n      this.fail((0, codegen_1._)(_templateObject34(), schemaCode, (0, codegen_1.or)(this.invalid$data(), condition)));\n    }\n  }, {\n    key: \"error\",\n    value: function error(append, errorParams, errorPaths) {\n      if (errorParams) {\n        this.setParams(errorParams);\n\n        this._error(append, errorPaths);\n\n        this.setParams({});\n        return;\n      }\n\n      this._error(append, errorPaths);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(append, errorPaths) {\n      ;\n      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n  }, {\n    key: \"$dataError\",\n    value: function $dataError() {\n      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n  }, {\n    key: \"ok\",\n    value: function ok(cond) {\n      if (!this.allErrors) this.gen.if(cond);\n    }\n  }, {\n    key: \"setParams\",\n    value: function setParams(obj, assign) {\n      if (assign) Object.assign(this.params, obj);else this.params = obj;\n    }\n  }, {\n    key: \"block$data\",\n    value: function block$data(valid, codeBlock) {\n      var _this = this;\n\n      var $dataValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : codegen_1.nil;\n      this.gen.block(function () {\n        _this.check$data(valid, $dataValid);\n\n        codeBlock();\n      });\n    }\n  }, {\n    key: \"check$data\",\n    value: function check$data() {\n      var valid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n      var $dataValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : codegen_1.nil;\n      if (!this.$data) return;\n      var gen = this.gen,\n          schemaCode = this.schemaCode,\n          schemaType = this.schemaType,\n          def = this.def;\n      gen.if((0, codegen_1.or)((0, codegen_1._)(_templateObject35(), schemaCode), $dataValid));\n      if (valid !== codegen_1.nil) gen.assign(valid, true);\n\n      if (schemaType.length || def.validateSchema) {\n        gen.elseIf(this.invalid$data());\n        this.$dataError();\n        if (valid !== codegen_1.nil) gen.assign(valid, false);\n      }\n\n      gen.else();\n    }\n  }, {\n    key: \"invalid$data\",\n    value: function invalid$data() {\n      var gen = this.gen,\n          schemaCode = this.schemaCode,\n          schemaType = this.schemaType,\n          def = this.def,\n          it = this.it;\n      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n\n      function wrong$DataType() {\n        if (schemaType.length) {\n          /* istanbul ignore if */\n          if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n          var st = Array.isArray(schemaType) ? schemaType : [schemaType];\n          return (0, codegen_1._)(_templateObject36(), (0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong));\n        }\n\n        return codegen_1.nil;\n      }\n\n      function invalid$DataSchema() {\n        if (def.validateSchema) {\n          var validateSchemaRef = gen.scopeValue(\"validate$data\", {\n            ref: def.validateSchema\n          }); // TODO value.code for standalone\n\n          return (0, codegen_1._)(_templateObject37(), validateSchemaRef, schemaCode);\n        }\n\n        return codegen_1.nil;\n      }\n    }\n  }, {\n    key: \"subschema\",\n    value: function subschema(appl, valid) {\n      var subschema = (0, subschema_1.getSubschema)(this.it, appl);\n      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n      (0, subschema_1.extendSubschemaMode)(subschema, appl);\n\n      var nextContext = _objectSpread(_objectSpread(_objectSpread({}, this.it), subschema), {}, {\n        items: undefined,\n        props: undefined\n      });\n\n      subschemaCode(nextContext, valid);\n      return nextContext;\n    }\n  }, {\n    key: \"mergeEvaluated\",\n    value: function mergeEvaluated(schemaCxt, toName) {\n      var it = this.it,\n          gen = this.gen;\n      if (!it.opts.unevaluated) return;\n\n      if (it.props !== true && schemaCxt.props !== undefined) {\n        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n      }\n\n      if (it.items !== true && schemaCxt.items !== undefined) {\n        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n      }\n    }\n  }, {\n    key: \"mergeValidEvaluated\",\n    value: function mergeValidEvaluated(schemaCxt, valid) {\n      var _this2 = this;\n\n      var it = this.it,\n          gen = this.gen;\n\n      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n        gen.if(valid, function () {\n          return _this2.mergeEvaluated(schemaCxt, codegen_1.Name);\n        });\n        return true;\n      }\n    }\n  }]);\n\n  return KeywordCxt;\n}();\n\nexports.KeywordCxt = KeywordCxt;\n\nfunction keywordCode(it, keyword, def, ruleType) {\n  var cxt = new KeywordCxt(it, def, keyword);\n\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  } else if (\"macro\" in def) {\n    (0, keyword_1.macroKeywordCode)(cxt, def);\n  } else if (def.compile || def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  }\n}\n\nvar JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nvar RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\n\nfunction getData($data, _ref5) {\n  var dataLevel = _ref5.dataLevel,\n      dataNames = _ref5.dataNames,\n      dataPathArr = _ref5.dataPathArr;\n  var jsonPointer;\n  var data;\n  if ($data === \"\") return names_1.default.rootData;\n\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    var matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    var up = +matches[1];\n    jsonPointer = matches[2];\n\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n\n  var expr = data;\n  var segments = jsonPointer.split(\"/\");\n\n  var _iterator3 = _createForOfIteratorHelper(segments),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var segment = _step3.value;\n\n      if (segment) {\n        data = (0, codegen_1._)(_templateObject38(), data, (0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment)));\n        expr = (0, codegen_1._)(_templateObject39(), expr, data);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return expr;\n\n  function errorMsg(pointerType, up) {\n    return \"Cannot access \".concat(pointerType, \" \").concat(up, \" levels up, current level is \").concat(dataLevel);\n  }\n}\n\nexports.getData = getData;","map":{"version":3,"sources":["../../../lib/compile/validate/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA,IAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AASA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA,C,CAQA;;;AACA,SAAgB,oBAAhB,CAAqC,EAArC,EAAkD;AAChD,MAAI,WAAW,CAAC,EAAD,CAAf,EAAqB;AACnB,IAAA,aAAa,CAAC,EAAD,CAAb;;AACA,QAAI,iBAAiB,CAAC,EAAD,CAArB,EAA2B;AACzB,MAAA,gBAAgB,CAAC,EAAD,CAAhB;AACA;AACD;AACF;;AACD,EAAA,gBAAgB,CAAC,EAAD,EAAK;AAAA,WAAM,CAAA,GAAA,YAAA,CAAA,oBAAA,EAAqB,EAArB,CAAN;AAAA,GAAL,CAAhB;AACD;;AATD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAWA,SAAS,gBAAT,OAEE,IAFF,EAEa;AAAA,MADV,GACU,QADV,GACU;AAAA,MADL,YACK,QADL,YACK;AAAA,MADS,MACT,QADS,MACT;AAAA,MADiB,SACjB,QADiB,SACjB;AAAA,MAD4B,IAC5B,QAD4B,IAC5B;;AAEX,MAAI,IAAI,CAAC,IAAL,CAAU,GAAd,EAAmB;AACjB,IAAA,GAAG,CAAC,IAAJ,CAAS,YAAT,GAAuB,GAAA,SAAA,CAAA,CAAvB,qBAA2B,OAAA,CAAA,OAAA,CAAE,IAA7B,EAAsC,OAAA,CAAA,OAAA,CAAE,MAAxC,GAAkD,SAAS,CAAC,MAA5D,EAAoE,YAAK;AACvE,MAAA,GAAG,CAAC,IAAJ,EAAS,GAAA,SAAA,CAAA,CAAT,sBAA2B,aAAa,CAAC,MAAD,EAAS,IAAT,CAAxC;AACA,MAAA,oBAAoB,CAAC,GAAD,EAAM,IAAN,CAApB;AACA,MAAA,GAAG,CAAC,IAAJ,CAAS,IAAT;AACD,KAJD;AAKD,GAND,MAMO;AACL,IAAA,GAAG,CAAC,IAAJ,CAAS,YAAT,GAAuB,GAAA,SAAA,CAAA,CAAvB,sBAA2B,OAAA,CAAA,OAAA,CAAE,IAA7B,EAAsC,iBAAiB,CAAC,IAAD,CAAvD,GAAiE,SAAS,CAAC,MAA3E,EAAmF;AAAA,aACjF,GAAG,CAAC,IAAJ,CAAS,aAAa,CAAC,MAAD,EAAS,IAAT,CAAtB,EAAsC,IAAtC,CAA2C,IAA3C,CADiF;AAAA,KAAnF;AAGD;AACF;;AAED,SAAS,iBAAT,CAA2B,IAA3B,EAAgD;AAC9C,UAAO,GAAA,SAAA,CAAA,CAAP,sBAAY,OAAA,CAAA,OAAA,CAAE,YAAd,EAAkC,OAAA,CAAA,OAAA,CAAE,UAApC,EAAmD,OAAA,CAAA,OAAA,CAAE,kBAArD,EAA4E,OAAA,CAAA,OAAA,CAAE,QAA9E,EACE,OAAA,CAAA,OAAA,CAAE,IADJ,EAEG,IAAI,CAAC,UAAL,IAAkB,GAAA,SAAA,CAAA,CAAlB,sBAAwB,OAAA,CAAA,OAAA,CAAE,cAA1B,IAAgD,SAAA,CAAA,GAFnD;AAGD;;AAED,SAAS,oBAAT,CAA8B,GAA9B,EAA4C,IAA5C,EAAiE;AAC/D,EAAA,GAAG,CAAC,EAAJ,CACE,OAAA,CAAA,OAAA,CAAE,MADJ,EAEE,YAAK;AACH,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,YAAV,GAAwB,GAAA,SAAA,CAAA,CAAxB,sBAA4B,OAAA,CAAA,OAAA,CAAE,MAA9B,EAAwC,OAAA,CAAA,OAAA,CAAE,YAA1C;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,UAAV,GAAsB,GAAA,SAAA,CAAA,CAAtB,sBAA0B,OAAA,CAAA,OAAA,CAAE,MAA5B,EAAsC,OAAA,CAAA,OAAA,CAAE,UAAxC;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,kBAAV,GAA8B,GAAA,SAAA,CAAA,CAA9B,sBAAkC,OAAA,CAAA,OAAA,CAAE,MAApC,EAA8C,OAAA,CAAA,OAAA,CAAE,kBAAhD;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,QAAV,GAAoB,GAAA,SAAA,CAAA,CAApB,sBAAwB,OAAA,CAAA,OAAA,CAAE,MAA1B,EAAoC,OAAA,CAAA,OAAA,CAAE,QAAtC;AACA,QAAI,IAAI,CAAC,UAAT,EAAqB,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,cAAV,GAA0B,GAAA,SAAA,CAAA,CAA1B,uBAA8B,OAAA,CAAA,OAAA,CAAE,MAAhC,EAA0C,OAAA,CAAA,OAAA,CAAE,cAA5C;AACtB,GARH,EASE,YAAK;AACH,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,YAAV,GAAwB,GAAA,SAAA,CAAA,CAAxB;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,UAAV,GAAsB,GAAA,SAAA,CAAA,CAAtB;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,kBAAV,GAA8B,GAAA,SAAA,CAAA,CAA9B;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,QAAV,EAAoB,OAAA,CAAA,OAAA,CAAE,IAAtB;AACA,QAAI,IAAI,CAAC,UAAT,EAAqB,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,cAAV,GAA0B,GAAA,SAAA,CAAA,CAA1B;AACtB,GAfH;AAiBD;;AAED,SAAS,gBAAT,CAA0B,EAA1B,EAA0C;AAAA,MACjC,MADiC,GACZ,EADY,CACjC,MADiC;AAAA,MACzB,IADyB,GACZ,EADY,CACzB,IADyB;AAAA,MACnB,GADmB,GACZ,EADY,CACnB,GADmB;AAExC,EAAA,gBAAgB,CAAC,EAAD,EAAK,YAAK;AACxB,QAAI,IAAI,CAAC,QAAL,IAAiB,MAAM,CAAC,QAA5B,EAAsC,cAAc,CAAC,EAAD,CAAd;AACtC,IAAA,cAAc,CAAC,EAAD,CAAd;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,OAAV,EAAmB,IAAnB;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAA,CAAA,OAAA,CAAE,MAAV,EAAkB,CAAlB;AACA,QAAI,IAAI,CAAC,WAAT,EAAsB,cAAc,CAAC,EAAD,CAAd;AACtB,IAAA,eAAe,CAAC,EAAD,CAAf;AACA,IAAA,aAAa,CAAC,EAAD,CAAb;AACD,GARe,CAAhB;AASA;AACD;;AAED,SAAS,cAAT,CAAwB,EAAxB,EAAwC;AACtC;AADsC,MAE/B,GAF+B,GAEV,EAFU,CAE/B,GAF+B;AAAA,MAE1B,YAF0B,GAEV,EAFU,CAE1B,YAF0B;AAGtC,EAAA,EAAE,CAAC,SAAH,GAAe,GAAG,CAAC,KAAJ,CAAU,WAAV,GAAuB,GAAA,SAAA,CAAA,CAAvB,uBAA2B,YAA3B,EAAf;AACA,EAAA,GAAG,CAAC,EAAJ,EAAO,GAAA,SAAA,CAAA,CAAP,uBAAW,EAAE,CAAC,SAAd,GAAwC;AAAA,WAAM,GAAG,CAAC,MAAJ,EAAW,GAAA,SAAA,CAAA,CAAX,uBAAe,EAAE,CAAC,SAAlB,IAAqC,GAAA,SAAA,CAAA,CAArC,uBAAN;AAAA,GAAxC;AACA,EAAA,GAAG,CAAC,EAAJ,EAAO,GAAA,SAAA,CAAA,CAAP,uBAAW,EAAE,CAAC,SAAd,GAAwC;AAAA,WAAM,GAAG,CAAC,MAAJ,EAAW,GAAA,SAAA,CAAA,CAAX,uBAAe,EAAE,CAAC,SAAlB,IAAqC,GAAA,SAAA,CAAA,CAArC,uBAAN;AAAA,GAAxC;AACD;;AAED,SAAS,aAAT,CAAuB,MAAvB,EAA0C,IAA1C,EAA+D;AAC7D,MAAM,KAAK,GAAG,OAAO,MAAP,IAAiB,QAAjB,IAA6B,MAAM,CAAC,IAAI,CAAC,QAAN,CAAjD;AACA,SAAO,KAAK,KAAK,IAAI,CAAC,IAAL,CAAU,MAAV,IAAoB,IAAI,CAAC,IAAL,CAAU,OAAnC,CAAL,IAAmD,GAAA,SAAA,CAAA,CAAnD,uBAAqE,KAArE,IAAkF,SAAA,CAAA,GAAzF;AACD,C,CAED;;;AACA,SAAS,aAAT,CAAuB,EAAvB,EAAsC,KAAtC,EAAiD;AAC/C,MAAI,WAAW,CAAC,EAAD,CAAf,EAAqB;AACnB,IAAA,aAAa,CAAC,EAAD,CAAb;;AACA,QAAI,iBAAiB,CAAC,EAAD,CAArB,EAA2B;AACzB,MAAA,gBAAgB,CAAC,EAAD,EAAK,KAAL,CAAhB;AACA;AACD;AACF;;AACD,GAAA,GAAA,YAAA,CAAA,iBAAA,EAAkB,EAAlB,EAAsB,KAAtB;AACD;;AAED,SAAS,iBAAT,QAAoD;AAAA,MAAxB,MAAwB,SAAxB,MAAwB;AAAA,MAAhB,IAAgB,SAAhB,IAAgB;AAClD,MAAI,OAAO,MAAP,IAAiB,SAArB,EAAgC,OAAO,CAAC,MAAR;;AAChC,OAAK,IAAM,GAAX,IAAkB,MAAlB;AAA0B,QAAI,IAAI,CAAC,KAAL,CAAW,GAAX,CAAe,GAAf,CAAJ,EAAyB,OAAO,IAAP;AAAnD;;AACA,SAAO,KAAP;AACD;;AAED,SAAS,WAAT,CAAqB,EAArB,EAAkC;AAChC,SAAO,OAAO,EAAE,CAAC,MAAV,IAAoB,SAA3B;AACD;;AAED,SAAS,gBAAT,CAA0B,EAA1B,EAA4C,KAA5C,EAAuD;AAAA,MAC9C,MAD8C,GACzB,EADyB,CAC9C,MAD8C;AAAA,MACtC,GADsC,GACzB,EADyB,CACtC,GADsC;AAAA,MACjC,IADiC,GACzB,EADyB,CACjC,IADiC;AAErD,MAAI,IAAI,CAAC,QAAL,IAAiB,MAAM,CAAC,QAA5B,EAAsC,cAAc,CAAC,EAAD,CAAd;AACtC,EAAA,aAAa,CAAC,EAAD,CAAb;AACA,EAAA,gBAAgB,CAAC,EAAD,CAAhB;AACA,MAAM,SAAS,GAAG,GAAG,CAAC,KAAJ,CAAU,OAAV,EAAmB,OAAA,CAAA,OAAA,CAAE,MAArB,CAAlB;AACA,EAAA,eAAe,CAAC,EAAD,EAAK,SAAL,CAAf,CANqD,CAOrD;;AACA,EAAA,GAAG,CAAC,GAAJ,CAAQ,KAAR,GAAe,GAAA,SAAA,CAAA,CAAf,uBAAmB,SAAnB,EAAoC,OAAA,CAAA,OAAA,CAAE,MAAtC;AACD;;AAED,SAAS,aAAT,CAAuB,EAAvB,EAAuC;AACrC,GAAA,GAAA,MAAA,CAAA,iBAAA,EAAkB,EAAlB;AACA,EAAA,oBAAoB,CAAC,EAAD,CAApB;AACD;;AAED,SAAS,eAAT,CAAyB,EAAzB,EAA2C,SAA3C,EAA2D;AACzD,MAAI,EAAE,CAAC,IAAH,CAAQ,GAAZ,EAAiB,OAAO,cAAc,CAAC,EAAD,EAAK,EAAL,EAAS,KAAT,EAAgB,SAAhB,CAArB;AACjB,MAAM,KAAK,GAAG,CAAA,GAAA,UAAA,CAAA,cAAA,EAAe,EAAE,CAAC,MAAlB,CAAd;AACA,MAAM,YAAY,GAAG,CAAA,GAAA,UAAA,CAAA,sBAAA,EAAuB,EAAvB,EAA2B,KAA3B,CAArB;AACA,EAAA,cAAc,CAAC,EAAD,EAAK,KAAL,EAAY,CAAC,YAAb,EAA2B,SAA3B,CAAd;AACD;;AAED,SAAS,oBAAT,CAA8B,EAA9B,EAA8C;AAAA,MACrC,MADqC,GACA,EADA,CACrC,MADqC;AAAA,MAC7B,aAD6B,GACA,EADA,CAC7B,aAD6B;AAAA,MACd,IADc,GACA,EADA,CACd,IADc;AAAA,MACR,IADQ,GACA,EADA,CACR,IADQ;;AAE5C,MAAI,MAAM,CAAC,IAAP,IAAe,IAAI,CAAC,qBAApB,IAA6C,CAAA,GAAA,MAAA,CAAA,oBAAA,EAAqB,MAArB,EAA6B,IAAI,CAAC,KAAlC,CAAjD,EAA2F;AACzF,IAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,sDAA8D,aAA9D;AACD;AACF;;AAED,SAAS,cAAT,CAAwB,EAAxB,EAAwC;AAAA,MAC/B,MAD+B,GACf,EADe,CAC/B,MAD+B;AAAA,MACvB,IADuB,GACf,EADe,CACvB,IADuB;;AAEtC,MAAI,MAAM,CAAC,OAAP,KAAmB,SAAnB,IAAgC,IAAI,CAAC,WAArC,IAAoD,IAAI,CAAC,YAA7D,EAA2E;AACzE,KAAA,GAAA,MAAA,CAAA,eAAA,EAAgB,EAAhB,EAAoB,uCAApB;AACD;AACF;;AAED,SAAS,aAAT,CAAuB,EAAvB,EAAuC;AACrC,MAAM,KAAK,GAAG,EAAE,CAAC,MAAH,CAAU,EAAE,CAAC,IAAH,CAAQ,QAAlB,CAAd;AACA,MAAI,KAAJ,EAAW,EAAE,CAAC,MAAH,GAAY,CAAA,GAAA,SAAA,CAAA,UAAA,EAAW,EAAE,CAAC,IAAH,CAAQ,WAAnB,EAAgC,EAAE,CAAC,MAAnC,EAA2C,KAA3C,CAAZ;AACZ;;AAED,SAAS,gBAAT,CAA0B,EAA1B,EAA0C;AACxC,MAAI,EAAE,CAAC,MAAH,CAAU,MAAV,IAAoB,CAAC,EAAE,CAAC,SAAH,CAAa,MAAtC,EAA8C,MAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AAC/C;;AAED,SAAS,cAAT,QAAmF;AAAA,MAA1D,GAA0D,SAA1D,GAA0D;AAAA,MAArD,SAAqD,SAArD,SAAqD;AAAA,MAA1C,MAA0C,SAA1C,MAA0C;AAAA,MAAlC,aAAkC,SAAlC,aAAkC;AAAA,MAAnB,IAAmB,SAAnB,IAAmB;AACjF,MAAM,GAAG,GAAG,MAAM,CAAC,QAAnB;;AACA,MAAI,IAAI,CAAC,QAAL,KAAkB,IAAtB,EAA4B;AAC1B,IAAA,GAAG,CAAC,IAAJ,EAAS,GAAA,SAAA,CAAA,CAAT,uBAAa,OAAA,CAAA,OAAA,CAAE,IAAf,EAAkC,GAAlC;AACD,GAFD,MAEO,IAAI,OAAO,IAAI,CAAC,QAAZ,IAAwB,UAA5B,EAAwC;AAC7C,QAAM,UAAU,IAAG,GAAA,SAAA,CAAA,GAAH,uBAAS,aAAT,CAAhB;AACA,QAAM,QAAQ,GAAG,GAAG,CAAC,UAAJ,CAAe,MAAf,EAAuB;AAAC,MAAA,GAAG,EAAE,SAAS,CAAC;AAAhB,KAAvB,CAAjB;AACA,IAAA,GAAG,CAAC,IAAJ,EAAS,GAAA,SAAA,CAAA,CAAT,uBAAa,OAAA,CAAA,OAAA,CAAE,IAAf,EAAqC,GAArC,EAA6C,UAA7C,EAA4D,QAA5D;AACD;AACF;;AAED,SAAS,aAAT,CAAuB,EAAvB,EAAoC;AAAA,MAC3B,GAD2B,GAC4B,EAD5B,CAC3B,GAD2B;AAAA,MACtB,SADsB,GAC4B,EAD5B,CACtB,SADsB;AAAA,MACX,YADW,GAC4B,EAD5B,CACX,YADW;AAAA,MACG,eADH,GAC4B,EAD5B,CACG,eADH;AAAA,MACoB,IADpB,GAC4B,EAD5B,CACoB,IADpB;;AAElC,MAAI,SAAS,CAAC,MAAd,EAAsB;AACpB;AACA,IAAA,GAAG,CAAC,EAAJ,EACE,GAAA,SAAA,CAAA,CADF,uBACM,OAAA,CAAA,OAAA,CAAE,MADR,GAEE;AAAA,aAAM,GAAG,CAAC,MAAJ,CAAW,OAAA,CAAA,OAAA,CAAE,IAAb,CAAN;AAAA,KAFF,EAGE;AAAA,aAAM,GAAG,CAAC,KAAJ,EAAU,GAAA,SAAA,CAAA,CAAV,uBAAkB,eAAlB,EAA6C,OAAA,CAAA,OAAA,CAAE,OAA/C,EAAN;AAAA,KAHF;AAKD,GAPD,MAOO;AACL,IAAA,GAAG,CAAC,MAAJ,EAAW,GAAA,SAAA,CAAA,CAAX,uBAAe,YAAf,GAAsC,OAAA,CAAA,OAAA,CAAE,OAAxC;AACA,QAAI,IAAI,CAAC,WAAT,EAAsB,eAAe,CAAC,EAAD,CAAf;AACtB,IAAA,GAAG,CAAC,MAAJ,EAAW,GAAA,SAAA,CAAA,CAAX,uBAAe,OAAA,CAAA,OAAA,CAAE,MAAjB;AACD;AACF;;AAED,SAAS,eAAT,QAAkE;AAAA,MAAxC,GAAwC,SAAxC,GAAwC;AAAA,MAAnC,SAAmC,SAAnC,SAAmC;AAAA,MAAxB,KAAwB,SAAxB,KAAwB;AAAA,MAAjB,KAAiB,SAAjB,KAAiB;AAChE,MAAI,KAAK,YAAY,SAAA,CAAA,IAArB,EAA2B,GAAG,CAAC,MAAJ,EAAW,GAAA,SAAA,CAAA,CAAX,uBAAe,SAAf,GAAkC,KAAlC;AAC3B,MAAI,KAAK,YAAY,SAAA,CAAA,IAArB,EAA2B,GAAG,CAAC,MAAJ,EAAW,GAAA,SAAA,CAAA,CAAX,uBAAe,SAAf,GAAkC,KAAlC;AAC5B;;AAED,SAAS,cAAT,CACE,EADF,EAEE,KAFF,EAGE,UAHF,EAIE,SAJF,EAIkB;AAAA,MAET,GAFS,GAEmC,EAFnC,CAET,GAFS;AAAA,MAEJ,MAFI,GAEmC,EAFnC,CAEJ,MAFI;AAAA,MAEI,IAFJ,GAEmC,EAFnC,CAEI,IAFJ;AAAA,MAEU,SAFV,GAEmC,EAFnC,CAEU,SAFV;AAAA,MAEqB,IAFrB,GAEmC,EAFnC,CAEqB,IAFrB;AAAA,MAE2B,IAF3B,GAEmC,EAFnC,CAE2B,IAF3B;AAAA,MAGT,KAHS,GAGA,IAHA,CAGT,KAHS;;AAIhB,MAAI,MAAM,CAAC,IAAP,KAAgB,IAAI,CAAC,qBAAL,IAA8B,CAAC,CAAA,GAAA,MAAA,CAAA,oBAAA,EAAqB,MAArB,EAA6B,KAA7B,CAA/C,CAAJ,EAAyF;AACvF,IAAA,GAAG,CAAC,KAAJ,CAAU;AAAA,aAAM,WAAW,CAAC,EAAD,EAAK,MAAL,EAAc,KAAK,CAAC,GAAN,CAAU,IAAV,CAAwB,UAAtC,CAAjB;AAAA,KAAV,EADuF,CACT;;AAC9E;AACD;;AACD,MAAI,CAAC,IAAI,CAAC,GAAV,EAAe,gBAAgB,CAAC,EAAD,EAAK,KAAL,CAAhB;AACf,EAAA,GAAG,CAAC,KAAJ,CAAU,YAAK;AAAA,+CACO,KAAK,CAAC,KADb;AAAA;;AAAA;AACb;AAAA,YAAW,KAAX;AAAiC,QAAA,aAAa,CAAC,KAAD,CAAb;AAAjC;AADa;AAAA;AAAA;AAAA;AAAA;;AAEb,IAAA,aAAa,CAAC,KAAK,CAAC,IAAP,CAAb;AACD,GAHD;;AAKA,WAAS,aAAT,CAAuB,KAAvB,EAAuC;AACrC,QAAI,CAAC,CAAA,GAAA,eAAA,CAAA,cAAA,EAAe,MAAf,EAAuB,KAAvB,CAAL,EAAoC;;AACpC,QAAI,KAAK,CAAC,IAAV,EAAgB;AACd,MAAA,GAAG,CAAC,EAAJ,CAAO,CAAA,GAAA,UAAA,CAAA,aAAA,EAAc,KAAK,CAAC,IAApB,EAA0B,IAA1B,EAAgC,IAAI,CAAC,aAArC,CAAP;AACA,MAAA,eAAe,CAAC,EAAD,EAAK,KAAL,CAAf;;AACA,UAAI,KAAK,CAAC,MAAN,KAAiB,CAAjB,IAAsB,KAAK,CAAC,CAAD,CAAL,KAAa,KAAK,CAAC,IAAzC,IAAiD,UAArD,EAAiE;AAC/D,QAAA,GAAG,CAAC,IAAJ;AACA,SAAA,GAAA,UAAA,CAAA,eAAA,EAAgB,EAAhB;AACD;;AACD,MAAA,GAAG,CAAC,KAAJ;AACD,KARD,MAQO;AACL,MAAA,eAAe,CAAC,EAAD,EAAK,KAAL,CAAf;AACD,KAZoC,CAarC;;;AACA,QAAI,CAAC,SAAL,EAAgB,GAAG,CAAC,EAAJ,EAAO,GAAA,SAAA,CAAA,CAAP,uBAAW,OAAA,CAAA,OAAA,CAAE,MAAb,EAA2B,SAAS,IAAI,CAAxC;AACjB;AACF;;AAED,SAAS,eAAT,CAAyB,EAAzB,EAA2C,KAA3C,EAA2D;AAAA,MAEvD,GAFuD,GAKrD,EALqD,CAEvD,GAFuD;AAAA,MAGvD,MAHuD,GAKrD,EALqD,CAGvD,MAHuD;AAAA,MAIhD,WAJgD,GAKrD,EALqD,CAIvD,IAJuD,CAIhD,WAJgD;AAMzD,MAAI,WAAJ,EAAiB,CAAA,GAAA,UAAA,CAAA,cAAA,EAAe,EAAf,EAAmB,KAAK,CAAC,IAAzB;AACjB,EAAA,GAAG,CAAC,KAAJ,CAAU,YAAK;AAAA,gDACM,KAAK,CAAC,KADZ;AAAA;;AAAA;AACb,6DAAgC;AAAA,YAArB,IAAqB;;AAC9B,YAAI,CAAA,GAAA,eAAA,CAAA,aAAA,EAAc,MAAd,EAAsB,IAAtB,CAAJ,EAAiC;AAC/B,UAAA,WAAW,CAAC,EAAD,EAAK,IAAI,CAAC,OAAV,EAAmB,IAAI,CAAC,UAAxB,EAAoC,KAAK,CAAC,IAA1C,CAAX;AACD;AACF;AALY;AAAA;AAAA;AAAA;AAAA;AAMd,GAND;AAOD;;AAED,SAAS,gBAAT,CAA0B,EAA1B,EAA4C,KAA5C,EAA6D;AAC3D,MAAI,EAAE,CAAC,SAAH,CAAa,IAAb,IAAqB,CAAC,EAAE,CAAC,IAAH,CAAQ,WAAlC,EAA+C;AAC/C,EAAA,iBAAiB,CAAC,EAAD,EAAK,KAAL,CAAjB;AACA,MAAI,CAAC,EAAE,CAAC,IAAH,CAAQ,eAAb,EAA8B,kBAAkB,CAAC,EAAD,EAAK,KAAL,CAAlB;AAC9B,EAAA,iBAAiB,CAAC,EAAD,EAAK,EAAE,CAAC,SAAR,CAAjB;AACD;;AAED,SAAS,iBAAT,CAA2B,EAA3B,EAA6C,KAA7C,EAA8D;AAC5D,MAAI,CAAC,KAAK,CAAC,MAAX,EAAmB;;AACnB,MAAI,CAAC,EAAE,CAAC,SAAH,CAAa,MAAlB,EAA0B;AACxB,IAAA,EAAE,CAAC,SAAH,GAAe,KAAf;AACA;AACD;;AACD,EAAA,KAAK,CAAC,OAAN,CAAc,UAAC,CAAD,EAAM;AAClB,QAAI,CAAC,YAAY,CAAC,EAAE,CAAC,SAAJ,EAAe,CAAf,CAAjB,EAAoC;AAClC,MAAA,gBAAgB,CAAC,EAAD,mBAAc,CAAd,yCAA4C,EAAE,CAAC,SAAH,CAAa,IAAb,CAAkB,GAAlB,CAA5C,QAAhB;AACD;AACF,GAJD;AAKA,EAAA,EAAE,CAAC,SAAH,GAAe,EAAE,CAAC,SAAH,CAAa,MAAb,CAAoB,UAAC,CAAD;AAAA,WAAO,YAAY,CAAC,KAAD,EAAQ,CAAR,CAAnB;AAAA,GAApB,CAAf;AACD;;AAED,SAAS,kBAAT,CAA4B,EAA5B,EAA8C,EAA9C,EAA4D;AAC1D,MAAI,EAAE,CAAC,MAAH,GAAY,CAAZ,IAAiB,EAAE,EAAE,CAAC,MAAH,KAAc,CAAd,IAAmB,EAAE,CAAC,QAAH,CAAY,MAAZ,CAArB,CAArB,EAAgE;AAC9D,IAAA,gBAAgB,CAAC,EAAD,EAAK,iDAAL,CAAhB;AACD;AACF;;AAED,SAAS,iBAAT,CAA2B,EAA3B,EAA6C,EAA7C,EAA2D;AACzD,MAAM,KAAK,GAAG,EAAE,CAAC,IAAH,CAAQ,KAAR,CAAc,GAA5B;;AACA,OAAK,IAAM,OAAX,IAAsB,KAAtB,EAA6B;AAC3B,QAAM,IAAI,GAAG,KAAK,CAAC,OAAD,CAAlB;;AACA,QAAI,OAAO,IAAP,IAAe,QAAf,IAA2B,CAAA,GAAA,eAAA,CAAA,aAAA,EAAc,EAAE,CAAC,MAAjB,EAAyB,IAAzB,CAA/B,EAA+D;AAAA,UACtD,IADsD,GAC9C,IAAI,CAAC,UADyC,CACtD,IADsD;;AAE7D,UAAI,IAAI,CAAC,MAAL,IAAe,CAAC,IAAI,CAAC,IAAL,CAAU,UAAC,CAAD;AAAA,eAAO,iBAAiB,CAAC,EAAD,EAAK,CAAL,CAAxB;AAAA,OAAV,CAApB,EAAgE;AAC9D,QAAA,gBAAgB,CAAC,EAAD,2BAAsB,IAAI,CAAC,IAAL,CAAU,GAAV,CAAtB,8BAAsD,OAAtD,QAAhB;AACD;AACF;AACF;AACF;;AAED,SAAS,iBAAT,CAA2B,KAA3B,EAA8C,IAA9C,EAA4D;AAC1D,SAAO,KAAK,CAAC,QAAN,CAAe,IAAf,KAAyB,IAAI,KAAK,QAAT,IAAqB,KAAK,CAAC,QAAN,CAAe,SAAf,CAArD;AACD;;AAED,SAAS,YAAT,CAAsB,EAAtB,EAAsC,CAAtC,EAAiD;AAC/C,SAAO,EAAE,CAAC,QAAH,CAAY,CAAZ,KAAmB,CAAC,KAAK,SAAN,IAAmB,EAAE,CAAC,QAAH,CAAY,QAAZ,CAA7C;AACD;;AAED,SAAS,gBAAT,CAA0B,EAA1B,EAA4C,GAA5C,EAAuD;AACrD,MAAM,UAAU,GAAG,EAAE,CAAC,SAAH,CAAa,MAAb,GAAsB,EAAE,CAAC,aAA5C;AACA,EAAA,GAAG,oBAAY,UAAZ,qBAAH;AACA,GAAA,GAAA,MAAA,CAAA,eAAA,EAAgB,EAAhB,EAAoB,GAApB,EAAyB,EAAE,CAAC,IAAH,CAAQ,WAAjC;AACD;;IAEY,U;AAiBX,sBAAY,EAAZ,EAA8B,GAA9B,EAA2D,OAA3D,EAA0E;AAAA;;AACxE,KAAA,GAAA,SAAA,CAAA,oBAAA,EAAqB,EAArB,EAAyB,GAAzB,EAA8B,OAA9B;AACA,SAAK,GAAL,GAAW,EAAE,CAAC,GAAd;AACA,SAAK,SAAL,GAAiB,EAAE,CAAC,SAApB;AACA,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,IAAL,GAAY,EAAE,CAAC,IAAf;AACA,SAAK,MAAL,GAAc,EAAE,CAAC,MAAH,CAAU,OAAV,CAAd;AACA,SAAK,KAAL,GAAa,GAAG,CAAC,KAAJ,IAAa,EAAE,CAAC,IAAH,CAAQ,KAArB,IAA8B,KAAK,MAAnC,IAA6C,KAAK,MAAL,CAAY,KAAtE;AACA,SAAK,WAAL,GAAmB,CAAA,GAAA,MAAA,CAAA,cAAA,EAAe,EAAf,EAAmB,KAAK,MAAxB,EAAgC,OAAhC,EAAyC,KAAK,KAA9C,CAAnB;AACA,SAAK,UAAL,GAAkB,GAAG,CAAC,UAAtB;AACA,SAAK,YAAL,GAAoB,EAAE,CAAC,MAAvB;AACA,SAAK,MAAL,GAAc,EAAd;AACA,SAAK,EAAL,GAAU,EAAV;AACA,SAAK,GAAL,GAAW,GAAX;;AAEA,QAAI,KAAK,KAAT,EAAgB;AACd,WAAK,UAAL,GAAkB,EAAE,CAAC,GAAH,CAAO,KAAP,CAAa,SAAb,EAAwB,OAAO,CAAC,KAAK,KAAN,EAAa,EAAb,CAA/B,CAAlB;AACD,KAFD,MAEO;AACL,WAAK,UAAL,GAAkB,KAAK,WAAvB;;AACA,UAAI,CAAC,CAAA,GAAA,SAAA,CAAA,eAAA,EAAgB,KAAK,MAArB,EAA6B,GAAG,CAAC,UAAjC,EAA6C,GAAG,CAAC,cAAjD,CAAL,EAAuE;AACrE,cAAM,IAAI,KAAJ,WAAa,OAAb,4BAAsC,IAAI,CAAC,SAAL,CAAe,GAAG,CAAC,UAAnB,CAAtC,EAAN;AACD;AACF;;AAED,QAAI,UAAU,GAAV,GAAgB,GAAG,CAAC,WAApB,GAAkC,GAAG,CAAC,MAAJ,KAAe,KAArD,EAA4D;AAC1D,WAAK,SAAL,GAAiB,EAAE,CAAC,GAAH,CAAO,KAAP,CAAa,OAAb,EAAsB,OAAA,CAAA,OAAA,CAAE,MAAxB,CAAjB;AACD;AACF;;;;2BAEM,S,EAAiB,a,EAA4B,U,EAAuB;AACzE,WAAK,UAAL,CAAgB,CAAA,GAAA,SAAA,CAAA,GAAA,EAAI,SAAJ,CAAhB,EAAgC,aAAhC,EAA+C,UAA/C;AACD;;;+BAEU,S,EAAiB,a,EAA4B,U,EAAuB;AAC7E,WAAK,GAAL,CAAS,EAAT,CAAY,SAAZ;AACA,UAAI,UAAJ,EAAgB,UAAU,GAA1B,KACK,KAAK,KAAL;;AACL,UAAI,aAAJ,EAAmB;AACjB,aAAK,GAAL,CAAS,IAAT;AACA,QAAA,aAAa;AACb,YAAI,KAAK,SAAT,EAAoB,KAAK,GAAL,CAAS,KAAT;AACrB,OAJD,MAIO;AACL,YAAI,KAAK,SAAT,EAAoB,KAAK,GAAL,CAAS,KAAT,GAApB,KACK,KAAK,GAAL,CAAS,IAAT;AACN;AACF;;;yBAEI,S,EAAiB,U,EAAuB;AAC3C,WAAK,UAAL,CAAgB,CAAA,GAAA,SAAA,CAAA,GAAA,EAAI,SAAJ,CAAhB,EAAgC,SAAhC,EAA2C,UAA3C;AACD;;;yBAEI,S,EAAgB;AACnB,UAAI,SAAS,KAAK,SAAlB,EAA6B;AAC3B,aAAK,KAAL;AACA,YAAI,CAAC,KAAK,SAAV,EAAqB,KAAK,GAAL,CAAS,EAAT,CAAY,KAAZ,EAFM,CAEa;;AACxC;AACD;;AACD,WAAK,GAAL,CAAS,EAAT,CAAY,SAAZ;AACA,WAAK,KAAL;AACA,UAAI,KAAK,SAAT,EAAoB,KAAK,GAAL,CAAS,KAAT,GAApB,KACK,KAAK,GAAL,CAAS,IAAT;AACN;;;8BAES,S,EAAe;AACvB,UAAI,CAAC,KAAK,KAAV,EAAiB,OAAO,KAAK,IAAL,CAAU,SAAV,CAAP;AADM,UAEhB,UAFgB,GAEF,IAFE,CAEhB,UAFgB;AAGvB,WAAK,IAAL,EAAU,GAAA,SAAA,CAAA,CAAV,uBAAc,UAAd,EAA8C,CAAA,GAAA,SAAA,CAAA,EAAA,EAAG,KAAK,YAAL,EAAH,EAAwB,SAAxB,CAA9C;AACD;;;0BAEK,M,EAAkB,W,EAAgC,U,EAAuB;AAC7E,UAAI,WAAJ,EAAiB;AACf,aAAK,SAAL,CAAe,WAAf;;AACA,aAAK,MAAL,CAAY,MAAZ,EAAoB,UAApB;;AACA,aAAK,SAAL,CAAe,EAAf;AACA;AACD;;AACD,WAAK,MAAL,CAAY,MAAZ,EAAoB,UAApB;AACD;;;2BAEc,M,EAAkB,U,EAAuB;AACtD;AAAC,OAAC,MAAM,GAAG,QAAA,CAAA,gBAAH,GAAsB,QAAA,CAAA,WAA7B,EAA0C,IAA1C,EAAgD,KAAK,GAAL,CAAS,KAAzD,EAAgE,UAAhE;AACF;;;iCAES;AACR,OAAA,GAAA,QAAA,CAAA,WAAA,EAAY,IAAZ,EAAkB,KAAK,GAAL,CAAS,UAAT,IAAuB,QAAA,CAAA,iBAAzC;AACD;;;4BAEI;AACH,UAAI,KAAK,SAAL,KAAmB,SAAvB,EAAkC,MAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AAClC,OAAA,GAAA,QAAA,CAAA,gBAAA,EAAiB,KAAK,GAAtB,EAA2B,KAAK,SAAhC;AACD;;;uBAEE,I,EAAoB;AACrB,UAAI,CAAC,KAAK,SAAV,EAAqB,KAAK,GAAL,CAAS,EAAT,CAAY,IAAZ;AACtB;;;8BAES,G,EAAuB,M,EAAa;AAC5C,UAAI,MAAJ,EAAY,MAAM,CAAC,MAAP,CAAc,KAAK,MAAnB,EAA2B,GAA3B,EAAZ,KACK,KAAK,MAAL,GAAc,GAAd;AACN;;;+BAEU,K,EAAa,S,EAA6C;AAAA;;AAAA,UAAtB,UAAsB,uEAAH,SAAA,CAAA,GAAG;AACnE,WAAK,GAAL,CAAS,KAAT,CAAe,YAAK;AAClB,QAAA,KAAI,CAAC,UAAL,CAAgB,KAAhB,EAAuB,UAAvB;;AACA,QAAA,SAAS;AACV,OAHD;AAID;;;iCAEmD;AAAA,UAAzC,KAAyC,uEAA3B,SAAA,CAAA,GAA2B;AAAA,UAAtB,UAAsB,uEAAH,SAAA,CAAA,GAAG;AAClD,UAAI,CAAC,KAAK,KAAV,EAAiB;AADiC,UAE3C,GAF2C,GAEP,IAFO,CAE3C,GAF2C;AAAA,UAEtC,UAFsC,GAEP,IAFO,CAEtC,UAFsC;AAAA,UAE1B,UAF0B,GAEP,IAFO,CAE1B,UAF0B;AAAA,UAEd,GAFc,GAEP,IAFO,CAEd,GAFc;AAGlD,MAAA,GAAG,CAAC,EAAJ,CAAO,CAAA,GAAA,SAAA,CAAA,EAAA,GAAG,GAAA,SAAA,CAAA,CAAH,uBAAO,UAAP,GAAmC,UAAnC,CAAP;AACA,UAAI,KAAK,KAAK,SAAA,CAAA,GAAd,EAAmB,GAAG,CAAC,MAAJ,CAAW,KAAX,EAAkB,IAAlB;;AACnB,UAAI,UAAU,CAAC,MAAX,IAAqB,GAAG,CAAC,cAA7B,EAA6C;AAC3C,QAAA,GAAG,CAAC,MAAJ,CAAW,KAAK,YAAL,EAAX;AACA,aAAK,UAAL;AACA,YAAI,KAAK,KAAK,SAAA,CAAA,GAAd,EAAmB,GAAG,CAAC,MAAJ,CAAW,KAAX,EAAkB,KAAlB;AACpB;;AACD,MAAA,GAAG,CAAC,IAAJ;AACD;;;mCAEW;AAAA,UACH,GADG,GACqC,IADrC,CACH,GADG;AAAA,UACE,UADF,GACqC,IADrC,CACE,UADF;AAAA,UACc,UADd,GACqC,IADrC,CACc,UADd;AAAA,UAC0B,GAD1B,GACqC,IADrC,CAC0B,GAD1B;AAAA,UAC+B,EAD/B,GACqC,IADrC,CAC+B,EAD/B;AAEV,aAAO,CAAA,GAAA,SAAA,CAAA,EAAA,EAAG,cAAc,EAAjB,EAAqB,kBAAkB,EAAvC,CAAP;;AAEA,eAAS,cAAT,GAAuB;AACrB,YAAI,UAAU,CAAC,MAAf,EAAuB;AACrB;AACA,cAAI,EAAE,UAAU,YAAY,SAAA,CAAA,IAAxB,CAAJ,EAAmC,MAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AACnC,cAAM,EAAE,GAAG,KAAK,CAAC,OAAN,CAAc,UAAd,IAA4B,UAA5B,GAAyC,CAAC,UAAD,CAApD;AACA,kBAAO,GAAA,SAAA,CAAA,CAAP,uBAAW,CAAA,GAAA,UAAA,CAAA,cAAA,EAAe,EAAf,EAAmB,UAAnB,EAA+B,EAAE,CAAC,IAAH,CAAQ,aAAvC,EAAsD,UAAA,CAAA,QAAA,CAAS,KAA/D,CAAX;AACD;;AACD,eAAO,SAAA,CAAA,GAAP;AACD;;AAED,eAAS,kBAAT,GAA2B;AACzB,YAAI,GAAG,CAAC,cAAR,EAAwB;AACtB,cAAM,iBAAiB,GAAG,GAAG,CAAC,UAAJ,CAAe,eAAf,EAAgC;AAAC,YAAA,GAAG,EAAE,GAAG,CAAC;AAAV,WAAhC,CAA1B,CADsB,CAC+D;;AACrF,kBAAO,GAAA,SAAA,CAAA,CAAP,uBAAY,iBAAZ,EAAiC,UAAjC;AACD;;AACD,eAAO,SAAA,CAAA,GAAP;AACD;AACF;;;8BAES,I,EAAqB,K,EAAW;AACxC,UAAM,SAAS,GAAG,CAAA,GAAA,WAAA,CAAA,YAAA,EAAa,KAAK,EAAlB,EAAsB,IAAtB,CAAlB;AACA,OAAA,GAAA,WAAA,CAAA,mBAAA,EAAoB,SAApB,EAA+B,KAAK,EAApC,EAAwC,IAAxC;AACA,OAAA,GAAA,WAAA,CAAA,mBAAA,EAAoB,SAApB,EAA+B,IAA/B;;AACA,UAAM,WAAW,iDAAO,KAAK,EAAZ,GAAmB,SAAnB;AAA8B,QAAA,KAAK,EAAE,SAArC;AAAgD,QAAA,KAAK,EAAE;AAAvD,QAAjB;;AACA,MAAA,aAAa,CAAC,WAAD,EAAc,KAAd,CAAb;AACA,aAAO,WAAP;AACD;;;mCAEc,S,EAAsB,M,EAAoB;AAAA,UAChD,EADgD,GACrC,IADqC,CAChD,EADgD;AAAA,UAC5C,GAD4C,GACrC,IADqC,CAC5C,GAD4C;AAEvD,UAAI,CAAC,EAAE,CAAC,IAAH,CAAQ,WAAb,EAA0B;;AAC1B,UAAI,EAAE,CAAC,KAAH,KAAa,IAAb,IAAqB,SAAS,CAAC,KAAV,KAAoB,SAA7C,EAAwD;AACtD,QAAA,EAAE,CAAC,KAAH,GAAW,MAAA,CAAA,cAAA,CAAe,KAAf,CAAqB,GAArB,EAA0B,SAAS,CAAC,KAApC,EAA2C,EAAE,CAAC,KAA9C,EAAqD,MAArD,CAAX;AACD;;AACD,UAAI,EAAE,CAAC,KAAH,KAAa,IAAb,IAAqB,SAAS,CAAC,KAAV,KAAoB,SAA7C,EAAwD;AACtD,QAAA,EAAE,CAAC,KAAH,GAAW,MAAA,CAAA,cAAA,CAAe,KAAf,CAAqB,GAArB,EAA0B,SAAS,CAAC,KAApC,EAA2C,EAAE,CAAC,KAA9C,EAAqD,MAArD,CAAX;AACD;AACF;;;wCAEmB,S,EAAsB,K,EAAW;AAAA;;AAAA,UAC5C,EAD4C,GACjC,IADiC,CAC5C,EAD4C;AAAA,UACxC,GADwC,GACjC,IADiC,CACxC,GADwC;;AAEnD,UAAI,EAAE,CAAC,IAAH,CAAQ,WAAR,KAAwB,EAAE,CAAC,KAAH,KAAa,IAAb,IAAqB,EAAE,CAAC,KAAH,KAAa,IAA1D,CAAJ,EAAqE;AACnE,QAAA,GAAG,CAAC,EAAJ,CAAO,KAAP,EAAc;AAAA,iBAAM,MAAI,CAAC,cAAL,CAAoB,SAApB,EAA+B,SAAA,CAAA,IAA/B,CAAN;AAAA,SAAd;AACA,eAAO,IAAP;AACD;AACF;;;;;;AA3LH,OAAA,CAAA,UAAA,GAAA,UAAA;;AA8LA,SAAS,WAAT,CACE,EADF,EAEE,OAFF,EAGE,GAHF,EAIE,QAJF,EAIqB;AAEnB,MAAM,GAAG,GAAG,IAAI,UAAJ,CAAe,EAAf,EAAmB,GAAnB,EAAwB,OAAxB,CAAZ;;AACA,MAAI,UAAU,GAAd,EAAmB;AACjB,IAAA,GAAG,CAAC,IAAJ,CAAS,GAAT,EAAc,QAAd;AACD,GAFD,MAEO,IAAI,GAAG,CAAC,KAAJ,IAAa,GAAG,CAAC,QAArB,EAA+B;AACpC,KAAA,GAAA,SAAA,CAAA,eAAA,EAAgB,GAAhB,EAAqB,GAArB;AACD,GAFM,MAEA,IAAI,WAAW,GAAf,EAAoB;AACzB,KAAA,GAAA,SAAA,CAAA,gBAAA,EAAiB,GAAjB,EAAsB,GAAtB;AACD,GAFM,MAEA,IAAI,GAAG,CAAC,OAAJ,IAAe,GAAG,CAAC,QAAvB,EAAiC;AACtC,KAAA,GAAA,SAAA,CAAA,eAAA,EAAgB,GAAhB,EAAqB,GAArB;AACD;AACF;;AAED,IAAM,YAAY,GAAG,qBAArB;AACA,IAAM,qBAAqB,GAAG,kCAA9B;;AACA,SAAgB,OAAhB,CACE,KADF,SAEgD;AAAA,MAA7C,SAA6C,SAA7C,SAA6C;AAAA,MAAlC,SAAkC,SAAlC,SAAkC;AAAA,MAAvB,WAAuB,SAAvB,WAAuB;AAE9C,MAAI,WAAJ;AACA,MAAI,IAAJ;AACA,MAAI,KAAK,KAAK,EAAd,EAAkB,OAAO,OAAA,CAAA,OAAA,CAAE,QAAT;;AAClB,MAAI,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsB;AACpB,QAAI,CAAC,YAAY,CAAC,IAAb,CAAkB,KAAlB,CAAL,EAA+B,MAAM,IAAI,KAAJ,iCAAmC,KAAnC,EAAN;AAC/B,IAAA,WAAW,GAAG,KAAd;AACA,IAAA,IAAI,GAAG,OAAA,CAAA,OAAA,CAAE,QAAT;AACD,GAJD,MAIO;AACL,QAAM,OAAO,GAAG,qBAAqB,CAAC,IAAtB,CAA2B,KAA3B,CAAhB;AACA,QAAI,CAAC,OAAL,EAAc,MAAM,IAAI,KAAJ,iCAAmC,KAAnC,EAAN;AACd,QAAM,EAAE,GAAW,CAAC,OAAO,CAAC,CAAD,CAA3B;AACA,IAAA,WAAW,GAAG,OAAO,CAAC,CAAD,CAArB;;AACA,QAAI,WAAW,KAAK,GAApB,EAAyB;AACvB,UAAI,EAAE,IAAI,SAAV,EAAqB,MAAM,IAAI,KAAJ,CAAU,QAAQ,CAAC,gBAAD,EAAmB,EAAnB,CAAlB,CAAN;AACrB,aAAO,WAAW,CAAC,SAAS,GAAG,EAAb,CAAlB;AACD;;AACD,QAAI,EAAE,GAAG,SAAT,EAAoB,MAAM,IAAI,KAAJ,CAAU,QAAQ,CAAC,MAAD,EAAS,EAAT,CAAlB,CAAN;AACpB,IAAA,IAAI,GAAG,SAAS,CAAC,SAAS,GAAG,EAAb,CAAhB;AACA,QAAI,CAAC,WAAL,EAAkB,OAAO,IAAP;AACnB;;AAED,MAAI,IAAI,GAAG,IAAX;AACA,MAAM,QAAQ,GAAG,WAAW,CAAC,KAAZ,CAAkB,GAAlB,CAAjB;;AAxB8C,8CAyBxB,QAzBwB;AAAA;;AAAA;AAyB9C,2DAAgC;AAAA,UAArB,OAAqB;;AAC9B,UAAI,OAAJ,EAAa;AACX,QAAA,IAAI,IAAG,GAAA,SAAA,CAAA,CAAH,uBAAO,IAAP,EAAc,CAAA,GAAA,SAAA,CAAA,WAAA,EAAY,CAAA,GAAA,MAAA,CAAA,mBAAA,EAAoB,OAApB,CAAZ,CAAd,CAAJ;AACA,QAAA,IAAI,IAAG,GAAA,SAAA,CAAA,CAAH,uBAAO,IAAP,EAAkB,IAAlB,CAAJ;AACD;AACF;AA9B6C;AAAA;AAAA;AAAA;AAAA;;AA+B9C,SAAO,IAAP;;AAEA,WAAS,QAAT,CAAkB,WAAlB,EAAuC,EAAvC,EAAiD;AAC/C,mCAAwB,WAAxB,cAAuC,EAAvC,0CAAyE,SAAzE;AACD;AACF;;AAtCD,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}