{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { addInspectMethod } from \"./isomorphic.node\";\nimport { isLazyStack, isWritableStack, joinStacks, lazyJoinStacks } from \"./stack\";\nimport { getDeepKeys, toJSON } from \"./to-json\";\nvar protectedProps = [\"name\", \"message\", \"stack\"];\n/**\n * Extends the new error with the properties of the original error and the `props` object.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n * @param props - Additional properties to add, if any\n */\n\nexport function extendError(newError, originalError, props) {\n  extendStack(newError, originalError); // Copy properties from the original error\n\n  if (originalError && typeof originalError === \"object\") {\n    mergeErrors(newError, originalError);\n  } // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.\n  // So replace it with one that outputs every property of the error.\n\n\n  newError.toJSON = toJSON; // On Node.js, add support for the `util.inspect()` method\n\n  if (addInspectMethod) {\n    addInspectMethod(newError);\n  } // Finally, copy custom properties that were specified by the user.\n  // These props OVERWRITE any previous props\n\n\n  if (props && typeof props === \"object\") {\n    Object.assign(newError, props);\n  }\n}\n/**\n * Extend the error stack to include its cause\n */\n\nfunction extendStack(newError, originalError) {\n  var stackProp = Object.getOwnPropertyDescriptor(newError, \"stack\");\n\n  if (isLazyStack(stackProp)) {\n    lazyJoinStacks(stackProp, newError, originalError);\n  } else if (isWritableStack(stackProp)) {\n    newError.stack = joinStacks(newError, originalError);\n  }\n}\n/**\n * Merges properties of the original error with the new error.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n */\n\n\nfunction mergeErrors(newError, originalError) {\n  // Get the original error's keys\n  // NOTE: We specifically exclude properties that we have already set on the new error.\n  // This is _especially_ important for the `stack` property, because this property has\n  // a lazy getter in some environments\n  var keys = getDeepKeys(originalError, protectedProps); // HACK: We have to cast the errors to `any` so we can use symbol indexers.\n  // see https://github.com/Microsoft/TypeScript/issues/1863\n  // tslint:disable: no-any no-unsafe-any\n\n  var _newError = newError;\n  var _originalError = originalError;\n\n  var _iterator = _createForOfIteratorHelper(keys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n\n      if (_newError[key] === undefined) {\n        try {\n          _newError[key] = _originalError[key];\n        } catch (e) {// This property is read-only, so it can't be copied\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}","map":{"version":3,"sources":["../src/extend-error.ts"],"names":[],"mappings":";AAAA,SAAS,gBAAT,QAAiC,mBAAjC;AACA,SAAS,WAAT,EAAsB,eAAtB,EAAuC,UAAvC,EAAmD,cAAnD,QAAyE,SAAzE;AACA,SAAS,WAAT,EAAsB,MAAtB,QAAoC,WAApC;AAGA,IAAM,cAAc,GAA2B,CAAC,MAAD,EAAS,SAAT,EAAoB,OAApB,CAA/C;AAEA;;;;;;AAMG;;AACH,OAAM,SAAU,WAAV,CAAyB,QAAzB,EAAgD,aAAhD,EAA2E,KAA3E,EAAyF;AAC7F,EAAA,WAAW,CAAC,QAAD,EAAW,aAAX,CAAX,CAD6F,CAG7F;;AACA,MAAI,aAAa,IAAI,OAAO,aAAP,KAAyB,QAA9C,EAAwD;AACtD,IAAA,WAAW,CAAC,QAAD,EAAW,aAAX,CAAX;AACD,GAN4F,CAQ7F;AACA;;;AACA,EAAA,QAAQ,CAAC,MAAT,GAAkB,MAAlB,CAV6F,CAY7F;;AACA,MAAI,gBAAJ,EAAsB;AACpB,IAAA,gBAAgB,CAAC,QAAD,CAAhB;AACD,GAf4F,CAiB7F;AACA;;;AACA,MAAI,KAAK,IAAI,OAAO,KAAP,KAAiB,QAA9B,EAAwC;AACtC,IAAA,MAAM,CAAC,MAAP,CAAc,QAAd,EAAwB,KAAxB;AACD;AACF;AAED;;AAEG;;AACH,SAAS,WAAT,CAAqB,QAArB,EAA0C,aAA1C,EAAmE;AACjE,MAAI,SAAS,GAAG,MAAM,CAAC,wBAAP,CAAgC,QAAhC,EAA0C,OAA1C,CAAhB;;AAEA,MAAI,WAAW,CAAC,SAAD,CAAf,EAA4B;AAC1B,IAAA,cAAc,CAAC,SAAD,EAAY,QAAZ,EAAsB,aAAtB,CAAd;AACD,GAFD,MAGK,IAAI,eAAe,CAAC,SAAD,CAAnB,EAAgC;AACnC,IAAA,QAAQ,CAAC,KAAT,GAAiB,UAAU,CAAC,QAAD,EAAW,aAAX,CAA3B;AACD;AACF;AAED;;;;;AAKG;;;AACH,SAAS,WAAT,CAAqB,QAArB,EAA0C,aAA1C,EAAkE;AAChE;AACA;AACA;AACA;AACA,MAAI,IAAI,GAAG,WAAW,CAAC,aAAD,EAAgB,cAAhB,CAAtB,CALgE,CAOhE;AACA;AACA;;AACA,MAAI,SAAS,GAAG,QAAhB;AACA,MAAI,cAAc,GAAG,aAArB;;AAXgE,6CAahD,IAbgD;AAAA;;AAAA;AAahE,wDAAsB;AAAA,UAAb,GAAa;;AACpB,UAAI,SAAS,CAAC,GAAD,CAAT,KAAmB,SAAvB,EAAkC;AAChC,YAAI;AACF,UAAA,SAAS,CAAC,GAAD,CAAT,GAAiB,cAAc,CAAC,GAAD,CAA/B;AACD,SAFD,CAGA,OAAO,CAAP,EAAU,CACR;AACD;AACF;AACF;AAtB+D;AAAA;AAAA;AAAA;AAAA;AAuBjE","sourceRoot":"","sourcesContent":["import { addInspectMethod } from \"./isomorphic.node\";\nimport { isLazyStack, isWritableStack, joinStacks, lazyJoinStacks } from \"./stack\";\nimport { getDeepKeys, toJSON } from \"./to-json\";\nconst protectedProps = [\"name\", \"message\", \"stack\"];\n/**\n * Extends the new error with the properties of the original error and the `props` object.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n * @param props - Additional properties to add, if any\n */\nexport function extendError(newError, originalError, props) {\n    extendStack(newError, originalError);\n    // Copy properties from the original error\n    if (originalError && typeof originalError === \"object\") {\n        mergeErrors(newError, originalError);\n    }\n    // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.\n    // So replace it with one that outputs every property of the error.\n    newError.toJSON = toJSON;\n    // On Node.js, add support for the `util.inspect()` method\n    if (addInspectMethod) {\n        addInspectMethod(newError);\n    }\n    // Finally, copy custom properties that were specified by the user.\n    // These props OVERWRITE any previous props\n    if (props && typeof props === \"object\") {\n        Object.assign(newError, props);\n    }\n}\n/**\n * Extend the error stack to include its cause\n */\nfunction extendStack(newError, originalError) {\n    let stackProp = Object.getOwnPropertyDescriptor(newError, \"stack\");\n    if (isLazyStack(stackProp)) {\n        lazyJoinStacks(stackProp, newError, originalError);\n    }\n    else if (isWritableStack(stackProp)) {\n        newError.stack = joinStacks(newError, originalError);\n    }\n}\n/**\n * Merges properties of the original error with the new error.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n */\nfunction mergeErrors(newError, originalError) {\n    // Get the original error's keys\n    // NOTE: We specifically exclude properties that we have already set on the new error.\n    // This is _especially_ important for the `stack` property, because this property has\n    // a lazy getter in some environments\n    let keys = getDeepKeys(originalError, protectedProps);\n    // HACK: We have to cast the errors to `any` so we can use symbol indexers.\n    // see https://github.com/Microsoft/TypeScript/issues/1863\n    // tslint:disable: no-any no-unsafe-any\n    let _newError = newError;\n    let _originalError = originalError;\n    for (let key of keys) {\n        if (_newError[key] === undefined) {\n            try {\n                _newError[key] = _originalError[key];\n            }\n            catch (e) {\n                // This property is read-only, so it can't be copied\n            }\n        }\n    }\n}\n//# sourceMappingURL=extend-error.js.map"]},"metadata":{},"sourceType":"module"}