{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _objectSpread = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\n\nvar validate_1 = require(\"./compile/validate\");\n\nObject.defineProperty(exports, \"KeywordCxt\", {\n  enumerable: true,\n  get: function get() {\n    return validate_1.KeywordCxt;\n  }\n});\n\nvar codegen_1 = require(\"./compile/codegen\");\n\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.str;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.stringify;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.nil;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.Name;\n  }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.CodeGen;\n  }\n});\n\nvar validation_error_1 = require(\"./runtime/validation_error\");\n\nvar ref_error_1 = require(\"./compile/ref_error\");\n\nvar rules_1 = require(\"./compile/rules\");\n\nvar compile_1 = require(\"./compile\");\n\nvar codegen_2 = require(\"./compile/codegen\");\n\nvar resolve_1 = require(\"./compile/resolve\");\n\nvar dataType_1 = require(\"./compile/validate/dataType\");\n\nvar util_1 = require(\"./compile/util\");\n\nvar $dataRefSchema = require(\"./refs/data.json\");\n\nvar defaultRegExp = function defaultRegExp(str, flags) {\n  return new RegExp(str, flags);\n};\n\ndefaultRegExp.code = \"new RegExp\";\nvar META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nvar EXT_SCOPE_NAMES = new Set([\"validate\", \"serialize\", \"parse\", \"wrapper\", \"root\", \"schema\", \"keyword\", \"pattern\", \"formats\", \"validate$data\", \"func\", \"obj\", \"Error\"]);\nvar removedOptions = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\"\n};\nvar deprecatedOptions = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n};\nvar MAX_EXPRESSION = 200; // eslint-disable-next-line complexity\n\nfunction requiredOptions(o) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;\n\n  var s = o.strict;\n\n  var _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n\n  var optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n  var regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n  return {\n    strictSchema: (_e = (_d = o.strictSchema) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,\n    strictNumbers: (_g = (_f = o.strictNumbers) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : true,\n    strictTypes: (_j = (_h = o.strictTypes) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : \"log\",\n    strictTuples: (_l = (_k = o.strictTuples) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : \"log\",\n    strictRequired: (_o = (_m = o.strictRequired) !== null && _m !== void 0 ? _m : s) !== null && _o !== void 0 ? _o : false,\n    code: o.code ? _objectSpread(_objectSpread({}, o.code), {}, {\n      optimize,\n      regExp\n    }) : {\n      optimize,\n      regExp\n    },\n    loopRequired: (_p = o.loopRequired) !== null && _p !== void 0 ? _p : MAX_EXPRESSION,\n    loopEnum: (_q = o.loopEnum) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n    meta: (_r = o.meta) !== null && _r !== void 0 ? _r : true,\n    messages: (_s = o.messages) !== null && _s !== void 0 ? _s : true,\n    inlineRefs: (_t = o.inlineRefs) !== null && _t !== void 0 ? _t : true,\n    schemaId: (_u = o.schemaId) !== null && _u !== void 0 ? _u : \"$id\",\n    addUsedSchema: (_v = o.addUsedSchema) !== null && _v !== void 0 ? _v : true,\n    validateSchema: (_w = o.validateSchema) !== null && _w !== void 0 ? _w : true,\n    validateFormats: (_x = o.validateFormats) !== null && _x !== void 0 ? _x : true,\n    unicodeRegExp: (_y = o.unicodeRegExp) !== null && _y !== void 0 ? _y : true,\n    int32range: (_z = o.int32range) !== null && _z !== void 0 ? _z : true\n  };\n}\n\nvar Ajv = /*#__PURE__*/function () {\n  function Ajv() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Ajv);\n\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    opts = this.opts = _objectSpread(_objectSpread({}, opts), requiredOptions(opts));\n    var _this$opts$code = this.opts.code,\n        es5 = _this$opts$code.es5,\n        lines = _this$opts$code.lines;\n    this.scope = new codegen_2.ValueScope({\n      scope: {},\n      prefixes: EXT_SCOPE_NAMES,\n      es5,\n      lines\n    });\n    this.logger = getLogger(opts.logger);\n    var formatOpt = opts.validateFormats;\n    opts.validateFormats = false;\n    this.RULES = (0, rules_1.getRules)();\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n    this._metaOpts = getMetaSchemaOptions.call(this);\n    if (opts.formats) addInitialFormats.call(this);\n\n    this._addVocabularies();\n\n    this._addDefaultMetaSchema();\n\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords);\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta);\n    addInitialSchemas.call(this);\n    opts.validateFormats = formatOpt;\n  }\n\n  _createClass(Ajv, [{\n    key: \"_addVocabularies\",\n    value: function _addVocabularies() {\n      this.addKeyword(\"$async\");\n    }\n  }, {\n    key: \"_addDefaultMetaSchema\",\n    value: function _addDefaultMetaSchema() {\n      var _this$opts = this.opts,\n          $data = _this$opts.$data,\n          meta = _this$opts.meta,\n          schemaId = _this$opts.schemaId;\n      var _dataRefSchema = $dataRefSchema;\n\n      if (schemaId === \"id\") {\n        _dataRefSchema = _objectSpread({}, $dataRefSchema);\n        _dataRefSchema.id = _dataRefSchema.$id;\n        delete _dataRefSchema.$id;\n      }\n\n      if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n  }, {\n    key: \"defaultMeta\",\n    value: function defaultMeta() {\n      var _this$opts2 = this.opts,\n          meta = _this$opts2.meta,\n          schemaId = _this$opts2.schemaId;\n      return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n      var v;\n\n      if (typeof schemaKeyRef == \"string\") {\n        v = this.getSchema(schemaKeyRef);\n        if (!v) throw new Error(\"no schema with key or ref \\\"\".concat(schemaKeyRef, \"\\\"\"));\n      } else {\n        v = this.compile(schemaKeyRef);\n      }\n\n      var valid = v(data);\n      if (!(\"$async\" in v)) this.errors = v.errors;\n      return valid;\n    }\n  }, {\n    key: \"compile\",\n    value: function compile(schema, _meta) {\n      var sch = this._addSchema(schema, _meta);\n\n      return sch.validate || this._compileSchemaEnv(sch);\n    }\n  }, {\n    key: \"compileAsync\",\n    value: function compileAsync(schema, meta) {\n      if (typeof this.opts.loadSchema != \"function\") {\n        throw new Error(\"options.loadSchema should be a function\");\n      }\n\n      var loadSchema = this.opts.loadSchema;\n      return runCompileAsync.call(this, schema, meta);\n\n      function runCompileAsync(_x2, _x3) {\n        return _runCompileAsync.apply(this, arguments);\n      }\n\n      function _runCompileAsync() {\n        _runCompileAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_schema, _meta) {\n          var sch;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return loadMetaSchema.call(this, _schema.$schema);\n\n                case 2:\n                  sch = this._addSchema(_schema, _meta);\n                  return _context.abrupt(\"return\", sch.validate || _compileAsync.call(this, sch));\n\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n        return _runCompileAsync.apply(this, arguments);\n      }\n\n      function loadMetaSchema(_x4) {\n        return _loadMetaSchema.apply(this, arguments);\n      }\n\n      function _loadMetaSchema() {\n        _loadMetaSchema = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2($ref) {\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!($ref && !this.getSchema($ref))) {\n                    _context2.next = 3;\n                    break;\n                  }\n\n                  _context2.next = 3;\n                  return runCompileAsync.call(this, {\n                    $ref\n                  }, true);\n\n                case 3:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n        return _loadMetaSchema.apply(this, arguments);\n      }\n\n      function _compileAsync(_x5) {\n        return _compileAsync2.apply(this, arguments);\n      }\n\n      function _compileAsync2() {\n        _compileAsync2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(sch) {\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.prev = 0;\n                  return _context3.abrupt(\"return\", this._compileSchemaEnv(sch));\n\n                case 4:\n                  _context3.prev = 4;\n                  _context3.t0 = _context3[\"catch\"](0);\n\n                  if (_context3.t0 instanceof ref_error_1.default) {\n                    _context3.next = 8;\n                    break;\n                  }\n\n                  throw _context3.t0;\n\n                case 8:\n                  checkLoaded.call(this, _context3.t0);\n                  _context3.next = 11;\n                  return loadMissingSchema.call(this, _context3.t0.missingSchema);\n\n                case 11:\n                  return _context3.abrupt(\"return\", _compileAsync.call(this, sch));\n\n                case 12:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this, [[0, 4]]);\n        }));\n        return _compileAsync2.apply(this, arguments);\n      }\n\n      function checkLoaded(_ref) {\n        var ref = _ref.missingSchema,\n            missingRef = _ref.missingRef;\n\n        if (this.refs[ref]) {\n          throw new Error(\"AnySchema \".concat(ref, \" is loaded but \").concat(missingRef, \" cannot be resolved\"));\n        }\n      }\n\n      function loadMissingSchema(_x6) {\n        return _loadMissingSchema.apply(this, arguments);\n      }\n\n      function _loadMissingSchema() {\n        _loadMissingSchema = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(ref) {\n          var _schema;\n\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return _loadSchema.call(this, ref);\n\n                case 2:\n                  _schema = _context4.sent;\n\n                  if (this.refs[ref]) {\n                    _context4.next = 6;\n                    break;\n                  }\n\n                  _context4.next = 6;\n                  return loadMetaSchema.call(this, _schema.$schema);\n\n                case 6:\n                  if (!this.refs[ref]) this.addSchema(_schema, ref, meta);\n\n                case 7:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n        return _loadMissingSchema.apply(this, arguments);\n      }\n\n      function _loadSchema(_x7) {\n        return _loadSchema2.apply(this, arguments);\n      }\n\n      function _loadSchema2() {\n        _loadSchema2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(ref) {\n          var p;\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  p = this._loading[ref];\n\n                  if (!p) {\n                    _context5.next = 3;\n                    break;\n                  }\n\n                  return _context5.abrupt(\"return\", p);\n\n                case 3:\n                  _context5.prev = 3;\n                  _context5.next = 6;\n                  return this._loading[ref] = loadSchema(ref);\n\n                case 6:\n                  return _context5.abrupt(\"return\", _context5.sent);\n\n                case 7:\n                  _context5.prev = 7;\n                  delete this._loading[ref];\n                  return _context5.finish(7);\n\n                case 10:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this, [[3,, 7, 10]]);\n        }));\n        return _loadSchema2.apply(this, arguments);\n      }\n    } // Adds schema to the instance\n\n  }, {\n    key: \"addSchema\",\n    value: function addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta) // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    {\n      var _validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n\n      if (Array.isArray(schema)) {\n        var _iterator = _createForOfIteratorHelper(schema),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var sch = _step.value;\n            this.addSchema(sch, undefined, _meta, _validateSchema);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return this;\n      }\n\n      var id;\n\n      if (typeof schema === \"object\") {\n        var schemaId = this.opts.schemaId;\n        id = schema[schemaId];\n\n        if (id !== undefined && typeof id != \"string\") {\n          throw new Error(\"schema \".concat(schemaId, \" must be string\"));\n        }\n      }\n\n      key = (0, resolve_1.normalizeId)(key || id);\n\n      this._checkUnique(key);\n\n      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n      return this;\n    } // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n\n  }, {\n    key: \"addMetaSchema\",\n    value: function addMetaSchema(schema, key) // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    {\n      var _validateSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.opts.validateSchema;\n\n      this.addSchema(schema, key, true, _validateSchema);\n      return this;\n    } //  Validate schema against its meta-schema\n\n  }, {\n    key: \"validateSchema\",\n    value: function validateSchema(schema, throwOrLogError) {\n      if (typeof schema == \"boolean\") return true;\n      var $schema;\n      $schema = schema.$schema;\n\n      if ($schema !== undefined && typeof $schema != \"string\") {\n        throw new Error(\"$schema must be a string\");\n      }\n\n      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n\n      if (!$schema) {\n        this.logger.warn(\"meta-schema not available\");\n        this.errors = null;\n        return true;\n      }\n\n      var valid = this.validate($schema, schema);\n\n      if (!valid && throwOrLogError) {\n        var message = \"schema is invalid: \" + this.errorsText();\n        if (this.opts.validateSchema === \"log\") this.logger.error(message);else throw new Error(message);\n      }\n\n      return valid;\n    } // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n\n  }, {\n    key: \"getSchema\",\n    value: function getSchema(keyRef) {\n      var sch;\n\n      while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") {\n        keyRef = sch;\n      }\n\n      if (sch === undefined) {\n        var schemaId = this.opts.schemaId;\n        var root = new compile_1.SchemaEnv({\n          schema: {},\n          schemaId\n        });\n        sch = compile_1.resolveSchema.call(this, root, keyRef);\n        if (!sch) return;\n        this.refs[keyRef] = sch;\n      }\n\n      return sch.validate || this._compileSchemaEnv(sch);\n    } // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n\n  }, {\n    key: \"removeSchema\",\n    value: function removeSchema(schemaKeyRef) {\n      if (schemaKeyRef instanceof RegExp) {\n        this._removeAllSchemas(this.schemas, schemaKeyRef);\n\n        this._removeAllSchemas(this.refs, schemaKeyRef);\n\n        return this;\n      }\n\n      switch (typeof schemaKeyRef) {\n        case \"undefined\":\n          this._removeAllSchemas(this.schemas);\n\n          this._removeAllSchemas(this.refs);\n\n          this._cache.clear();\n\n          return this;\n\n        case \"string\":\n          {\n            var sch = getSchEnv.call(this, schemaKeyRef);\n            if (typeof sch == \"object\") this._cache.delete(sch.schema);\n            delete this.schemas[schemaKeyRef];\n            delete this.refs[schemaKeyRef];\n            return this;\n          }\n\n        case \"object\":\n          {\n            var cacheKey = schemaKeyRef;\n\n            this._cache.delete(cacheKey);\n\n            var id = schemaKeyRef[this.opts.schemaId];\n\n            if (id) {\n              id = (0, resolve_1.normalizeId)(id);\n              delete this.schemas[id];\n              delete this.refs[id];\n            }\n\n            return this;\n          }\n\n        default:\n          throw new Error(\"ajv.removeSchema: invalid parameter\");\n      }\n    } // add \"vocabulary\" - a collection of keywords\n\n  }, {\n    key: \"addVocabulary\",\n    value: function addVocabulary(definitions) {\n      var _iterator2 = _createForOfIteratorHelper(definitions),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var def = _step2.value;\n          this.addKeyword(def);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addKeyword\",\n    value: function addKeyword(kwdOrDef, def // deprecated\n    ) {\n      var _this = this;\n\n      var keyword;\n\n      if (typeof kwdOrDef == \"string\") {\n        keyword = kwdOrDef;\n\n        if (typeof def == \"object\") {\n          this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n          def.keyword = keyword;\n        }\n      } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n        def = kwdOrDef;\n        keyword = def.keyword;\n\n        if (Array.isArray(keyword) && !keyword.length) {\n          throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n        }\n      } else {\n        throw new Error(\"invalid addKeywords parameters\");\n      }\n\n      checkKeyword.call(this, keyword, def);\n\n      if (!def) {\n        (0, util_1.eachItem)(keyword, function (kwd) {\n          return addRule.call(_this, kwd);\n        });\n        return this;\n      }\n\n      keywordMetaschema.call(this, def);\n\n      var definition = _objectSpread(_objectSpread({}, def), {}, {\n        type: (0, dataType_1.getJSONTypes)(def.type),\n        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n      });\n\n      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? function (k) {\n        return addRule.call(_this, k, definition);\n      } : function (k) {\n        return definition.type.forEach(function (t) {\n          return addRule.call(_this, k, definition, t);\n        });\n      });\n      return this;\n    }\n  }, {\n    key: \"getKeyword\",\n    value: function getKeyword(keyword) {\n      var rule = this.RULES.all[keyword];\n      return typeof rule == \"object\" ? rule.definition : !!rule;\n    } // Remove keyword\n\n  }, {\n    key: \"removeKeyword\",\n    value: function removeKeyword(keyword) {\n      // TODO return type should be Ajv\n      var RULES = this.RULES;\n      delete RULES.keywords[keyword];\n      delete RULES.all[keyword];\n\n      var _iterator3 = _createForOfIteratorHelper(RULES.rules),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var group = _step3.value;\n          var i = group.rules.findIndex(function (rule) {\n            return rule.keyword === keyword;\n          });\n          if (i >= 0) group.rules.splice(i, 1);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return this;\n    } // Add format\n\n  }, {\n    key: \"addFormat\",\n    value: function addFormat(name, format) {\n      if (typeof format == \"string\") format = new RegExp(format);\n      this.formats[name] = format;\n      return this;\n    }\n  }, {\n    key: \"errorsText\",\n    value: function errorsText() // optional options with properties `separator` and `dataVar`\n    {\n      var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.errors;\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$separator = _ref2.separator,\n          separator = _ref2$separator === void 0 ? \", \" : _ref2$separator,\n          _ref2$dataVar = _ref2.dataVar,\n          dataVar = _ref2$dataVar === void 0 ? \"data\" : _ref2$dataVar;\n\n      if (!errors || errors.length === 0) return \"No errors\";\n      return errors.map(function (e) {\n        return \"\".concat(dataVar).concat(e.instancePath, \" \").concat(e.message);\n      }).reduce(function (text, msg) {\n        return text + separator + msg;\n      });\n    }\n  }, {\n    key: \"$dataMetaSchema\",\n    value: function $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n      var rules = this.RULES.all;\n      metaSchema = JSON.parse(JSON.stringify(metaSchema));\n\n      var _iterator4 = _createForOfIteratorHelper(keywordsJsonPointers),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var jsonPointer = _step4.value;\n          var segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n\n          var keywords = metaSchema;\n\n          var _iterator5 = _createForOfIteratorHelper(segments),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var seg = _step5.value;\n              keywords = keywords[seg];\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          for (var key in rules) {\n            var rule = rules[key];\n            if (typeof rule != \"object\") continue;\n            var $data = rule.definition.$data;\n            var schema = keywords[key];\n            if ($data && schema) keywords[key] = schemaOrData(schema);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return metaSchema;\n    }\n  }, {\n    key: \"_removeAllSchemas\",\n    value: function _removeAllSchemas(schemas, regex) {\n      for (var keyRef in schemas) {\n        var sch = schemas[keyRef];\n\n        if (!regex || regex.test(keyRef)) {\n          if (typeof sch == \"string\") {\n            delete schemas[keyRef];\n          } else if (sch && !sch.meta) {\n            this._cache.delete(sch.schema);\n\n            delete schemas[keyRef];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_addSchema\",\n    value: function _addSchema(schema, meta, baseId) {\n      var validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n      var addSchema = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.addUsedSchema;\n      var id;\n      var schemaId = this.opts.schemaId;\n\n      if (typeof schema == \"object\") {\n        id = schema[schemaId];\n      } else {\n        if (this.opts.jtd) throw new Error(\"schema must be object\");else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\");\n      }\n\n      var sch = this._cache.get(schema);\n\n      if (sch !== undefined) return sch;\n      baseId = (0, resolve_1.normalizeId)(id || baseId);\n      var localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n      sch = new compile_1.SchemaEnv({\n        schema,\n        schemaId,\n        meta,\n        baseId,\n        localRefs\n      });\n\n      this._cache.set(sch.schema, sch);\n\n      if (addSchema && !baseId.startsWith(\"#\")) {\n        // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n        if (baseId) this._checkUnique(baseId);\n        this.refs[baseId] = sch;\n      }\n\n      if (validateSchema) this.validateSchema(schema, true);\n      return sch;\n    }\n  }, {\n    key: \"_checkUnique\",\n    value: function _checkUnique(id) {\n      if (this.schemas[id] || this.refs[id]) {\n        throw new Error(\"schema with key or id \\\"\".concat(id, \"\\\" already exists\"));\n      }\n    }\n  }, {\n    key: \"_compileSchemaEnv\",\n    value: function _compileSchemaEnv(sch) {\n      if (sch.meta) this._compileMetaSchema(sch);else compile_1.compileSchema.call(this, sch);\n      /* istanbul ignore if */\n\n      if (!sch.validate) throw new Error(\"ajv implementation error\");\n      return sch.validate;\n    }\n  }, {\n    key: \"_compileMetaSchema\",\n    value: function _compileMetaSchema(sch) {\n      var currentOpts = this.opts;\n      this.opts = this._metaOpts;\n\n      try {\n        compile_1.compileSchema.call(this, sch);\n      } finally {\n        this.opts = currentOpts;\n      }\n    }\n  }]);\n\n  return Ajv;\n}();\n\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\n\nfunction checkOptions(checkOpts, options, msg) {\n  var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"error\";\n\n  for (var key in checkOpts) {\n    var opt = key;\n    if (opt in options) this.logger[log](\"\".concat(msg, \": option \").concat(key, \". \").concat(checkOpts[opt]));\n  }\n}\n\nfunction getSchEnv(keyRef) {\n  keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n\n  return this.schemas[keyRef] || this.refs[keyRef];\n}\n\nfunction addInitialSchemas() {\n  var optsSchemas = this.opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);else for (var key in optsSchemas) {\n    this.addSchema(optsSchemas[key], key);\n  }\n}\n\nfunction addInitialFormats() {\n  for (var name in this.opts.formats) {\n    var format = this.opts.formats[name];\n    if (format) this.addFormat(name, format);\n  }\n}\n\nfunction addInitialKeywords(defs) {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs);\n    return;\n  }\n\n  this.logger.warn(\"keywords option as map is deprecated, pass array\");\n\n  for (var keyword in defs) {\n    var def = defs[keyword];\n    if (!def.keyword) def.keyword = keyword;\n    this.addKeyword(def);\n  }\n}\n\nfunction getMetaSchemaOptions() {\n  var metaOpts = _objectSpread({}, this.opts);\n\n  var _iterator6 = _createForOfIteratorHelper(META_IGNORE_OPTIONS),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var opt = _step6.value;\n      delete metaOpts[opt];\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return metaOpts;\n}\n\nvar noLogs = {\n  log() {},\n\n  warn() {},\n\n  error() {}\n\n};\n\nfunction getLogger(logger) {\n  if (logger === false) return noLogs;\n  if (logger === undefined) return console;\n  if (logger.log && logger.warn && logger.error) return logger;\n  throw new Error(\"logger must implement log, warn and error methods\");\n}\n\nvar KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\n\nfunction checkKeyword(keyword, def) {\n  var RULES = this.RULES;\n  (0, util_1.eachItem)(keyword, function (kwd) {\n    if (RULES.keywords[kwd]) throw new Error(\"Keyword \".concat(kwd, \" is already defined\"));\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(\"Keyword \".concat(kwd, \" has invalid name\"));\n  });\n  if (!def) return;\n\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function');\n  }\n}\n\nfunction addRule(keyword, definition, dataType) {\n  var _this2 = this;\n\n  var _a;\n\n  var post = definition === null || definition === void 0 ? void 0 : definition.post;\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  var RULES = this.RULES;\n  var ruleGroup = post ? RULES.post : RULES.rules.find(function (_ref3) {\n    var t = _ref3.type;\n    return t === dataType;\n  });\n\n  if (!ruleGroup) {\n    ruleGroup = {\n      type: dataType,\n      rules: []\n    };\n    RULES.rules.push(ruleGroup);\n  }\n\n  RULES.keywords[keyword] = true;\n  if (!definition) return;\n  var rule = {\n    keyword,\n    definition: _objectSpread(_objectSpread({}, definition), {}, {\n      type: (0, dataType_1.getJSONTypes)(definition.type),\n      schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n    })\n  };\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);else ruleGroup.rules.push(rule);\n  RULES.all[keyword] = rule;\n  (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach(function (kwd) {\n    return _this2.addKeyword(kwd);\n  });\n}\n\nfunction addBeforeRule(ruleGroup, rule, before) {\n  var i = ruleGroup.rules.findIndex(function (_rule) {\n    return _rule.keyword === before;\n  });\n\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule);\n  } else {\n    ruleGroup.rules.push(rule);\n    this.logger.warn(\"rule \".concat(before, \" is not defined\"));\n  }\n}\n\nfunction keywordMetaschema(def) {\n  var metaSchema = def.metaSchema;\n  if (metaSchema === undefined) return;\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);\n  def.validateSchema = this.compile(metaSchema, true);\n}\n\nvar $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\n\nfunction schemaOrData(schema) {\n  return {\n    anyOf: [schema, $dataRef]\n  };\n}","map":{"version":3,"sources":["../lib/core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    return {\n        strictSchema: (_e = (_d = o.strictSchema) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,\n        strictNumbers: (_g = (_f = o.strictNumbers) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : true,\n        strictTypes: (_j = (_h = o.strictTypes) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : \"log\",\n        strictTuples: (_l = (_k = o.strictTuples) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : \"log\",\n        strictRequired: (_o = (_m = o.strictRequired) !== null && _m !== void 0 ? _m : s) !== null && _o !== void 0 ? _o : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_p = o.loopRequired) !== null && _p !== void 0 ? _p : MAX_EXPRESSION,\n        loopEnum: (_q = o.loopEnum) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        meta: (_r = o.meta) !== null && _r !== void 0 ? _r : true,\n        messages: (_s = o.messages) !== null && _s !== void 0 ? _s : true,\n        inlineRefs: (_t = o.inlineRefs) !== null && _t !== void 0 ? _t : true,\n        schemaId: (_u = o.schemaId) !== null && _u !== void 0 ? _u : \"$id\",\n        addUsedSchema: (_v = o.addUsedSchema) !== null && _v !== void 0 ? _v : true,\n        validateSchema: (_w = o.validateSchema) !== null && _w !== void 0 ? _w : true,\n        validateFormats: (_x = o.validateFormats) !== null && _x !== void 0 ? _x : true,\n        unicodeRegExp: (_y = o.unicodeRegExp) !== null && _y !== void 0 ? _y : true,\n        int32range: (_z = o.int32range) !== null && _z !== void 0 ? _z : true,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"script"}