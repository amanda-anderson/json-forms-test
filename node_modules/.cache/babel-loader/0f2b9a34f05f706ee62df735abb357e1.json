{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar Options = require(\"./options\");\n\nvar $Refs = require(\"./refs\");\n\nvar parse = require(\"./parse\");\n\nvar normalizeArgs = require(\"./normalize-args\");\n\nvar resolveExternal = require(\"./resolve-external\");\n\nvar bundle = require(\"./bundle\");\n\nvar dereference = require(\"./dereference\");\n\nvar url = require(\"./util/url\");\n\nvar maybe = require(\"call-me-maybe\");\n\nvar _require = require(\"ono\"),\n    ono = _require.ono;\n\nmodule.exports = $RefParser;\nmodule.exports.YAML = require(\"./util/yaml\");\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\n\nfunction $RefParser() {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n\n  this.$refs = new $Refs();\n}\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n\n\n$RefParser.parse = function (path, schema, options, callback) {\n  var Class = this; // eslint-disable-line consistent-this\n\n  var instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n\n\n$RefParser.prototype.parse = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, schema, options, callback) {\n    var args,\n        promise,\n        err,\n        pathType,\n        $ref,\n        me,\n        result,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            args = normalizeArgs(_args);\n\n            if (!(!args.path && !args.schema)) {\n              _context.next = 4;\n              break;\n            }\n\n            err = ono(\"Expected a file path, URL, or object. Got \".concat(args.path || args.schema));\n            return _context.abrupt(\"return\", maybe(args.callback, Promise.reject(err)));\n\n          case 4:\n            // Reset everything\n            this.schema = null;\n            this.$refs = new $Refs(); // If the path is a filesystem path, then convert it to a URL.\n            // NOTE: According to the JSON Reference spec, these should already be URLs,\n            // but, in practice, many people use local filesystem paths instead.\n            // So we're being generous here and doing the conversion automatically.\n            // This is not intended to be a 100% bulletproof solution.\n            // If it doesn't work for your use-case, then use a URL instead.\n\n            pathType = \"http\";\n\n            if (url.isFileSystemPath(args.path)) {\n              args.path = url.fromFileSystemPath(args.path);\n              pathType = \"file\";\n            } // Resolve the absolute path of the schema\n\n\n            args.path = url.resolve(url.cwd(), args.path);\n\n            if (args.schema && typeof args.schema === \"object\") {\n              // A schema object was passed-in.\n              // So immediately add a new $Ref with the schema object as its value\n              $ref = this.$refs._add(args.path);\n              $ref.value = args.schema;\n              $ref.pathType = pathType;\n              promise = Promise.resolve(args.schema);\n            } else {\n              // Parse the schema file/url\n              promise = parse(args.path, this.$refs, args.options);\n            }\n\n            me = this;\n            _context.prev = 11;\n            _context.next = 14;\n            return promise;\n\n          case 14:\n            result = _context.sent;\n\n            if (!(!result || typeof result !== \"object\" || Buffer.isBuffer(result))) {\n              _context.next = 19;\n              break;\n            }\n\n            throw ono.syntax(\"\\\"\".concat(me.$refs._root$Ref.path || result, \"\\\" is not a valid JSON Schema\"));\n\n          case 19:\n            me.schema = result;\n            return _context.abrupt(\"return\", maybe(args.callback, Promise.resolve(me.schema)));\n\n          case 21:\n            _context.next = 26;\n            break;\n\n          case 23:\n            _context.prev = 23;\n            _context.t0 = _context[\"catch\"](11);\n            return _context.abrupt(\"return\", maybe(args.callback, Promise.reject(_context.t0)));\n\n          case 26:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[11, 23]]);\n  }));\n\n  return function (_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n\n\n$RefParser.resolve = function (path, schema, options, callback) {\n  var Class = this; // eslint-disable-line consistent-this\n\n  var instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n\n\n$RefParser.prototype.resolve = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path, schema, options, callback) {\n    var me,\n        args,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            me = this;\n            args = normalizeArgs(_args2);\n            _context2.prev = 2;\n            _context2.next = 5;\n            return this.parse(args.path, args.schema, args.options);\n\n          case 5:\n            _context2.next = 7;\n            return resolveExternal(me, args.options);\n\n          case 7:\n            return _context2.abrupt(\"return\", maybe(args.callback, Promise.resolve(me.$refs)));\n\n          case 10:\n            _context2.prev = 10;\n            _context2.t0 = _context2[\"catch\"](2);\n            return _context2.abrupt(\"return\", maybe(args.callback, Promise.reject(_context2.t0)));\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this, [[2, 10]]);\n  }));\n\n  return function (_x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n\n\n$RefParser.bundle = function (path, schema, options, callback) {\n  var Class = this; // eslint-disable-line consistent-this\n\n  var instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n\n\n$RefParser.prototype.bundle = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path, schema, options, callback) {\n    var me,\n        args,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            me = this;\n            args = normalizeArgs(_args3);\n            _context3.prev = 2;\n            _context3.next = 5;\n            return this.resolve(args.path, args.schema, args.options);\n\n          case 5:\n            bundle(me, args.options);\n            return _context3.abrupt(\"return\", maybe(args.callback, Promise.resolve(me.schema)));\n\n          case 9:\n            _context3.prev = 9;\n            _context3.t0 = _context3[\"catch\"](2);\n            return _context3.abrupt(\"return\", maybe(args.callback, Promise.reject(_context3.t0)));\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this, [[2, 9]]);\n  }));\n\n  return function (_x9, _x10, _x11, _x12) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n\n\n$RefParser.dereference = function (path, schema, options, callback) {\n  var Class = this; // eslint-disable-line consistent-this\n\n  var instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n\n\n$RefParser.prototype.dereference = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path, schema, options, callback) {\n    var me,\n        args,\n        _args4 = arguments;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            me = this;\n            args = normalizeArgs(_args4);\n            _context4.prev = 2;\n            _context4.next = 5;\n            return this.resolve(args.path, args.schema, args.options);\n\n          case 5:\n            dereference(me, args.options);\n            return _context4.abrupt(\"return\", maybe(args.callback, Promise.resolve(me.schema)));\n\n          case 9:\n            _context4.prev = 9;\n            _context4.t0 = _context4[\"catch\"](2);\n            return _context4.abrupt(\"return\", maybe(args.callback, Promise.reject(_context4.t0)));\n\n          case 12:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, this, [[2, 9]]);\n  }));\n\n  return function (_x13, _x14, _x15, _x16) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/json-schema-ref-parser/lib/index.js"],"names":["Options","require","$Refs","parse","normalizeArgs","resolveExternal","bundle","dereference","url","maybe","ono","module","exports","$RefParser","YAML","schema","$refs","path","options","callback","Class","instance","apply","arguments","prototype","args","err","Promise","reject","pathType","isFileSystemPath","fromFileSystemPath","resolve","cwd","$ref","_add","value","promise","me","result","Buffer","isBuffer","syntax","_root$Ref"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst Options = require(\"./options\");\nconst $Refs = require(\"./refs\");\nconst parse = require(\"./parse\");\nconst normalizeArgs = require(\"./normalize-args\");\nconst resolveExternal = require(\"./resolve-external\");\nconst bundle = require(\"./bundle\");\nconst dereference = require(\"./dereference\");\nconst url = require(\"./util/url\");\nconst maybe = require(\"call-me-maybe\");\nconst { ono } = require(\"ono\");\n\nmodule.exports = $RefParser;\nmodule.exports.YAML = require(\"./util/yaml\");\n\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\nfunction $RefParser () {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n  this.$refs = new $Refs();\n}\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.parse = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.prototype.parse = async function (path, schema, options, callback) {\n  let args = normalizeArgs(arguments);\n  let promise;\n\n  if (!args.path && !args.schema) {\n    let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n    return maybe(args.callback, Promise.reject(err));\n  }\n\n  // Reset everything\n  this.schema = null;\n  this.$refs = new $Refs();\n\n  // If the path is a filesystem path, then convert it to a URL.\n  // NOTE: According to the JSON Reference spec, these should already be URLs,\n  // but, in practice, many people use local filesystem paths instead.\n  // So we're being generous here and doing the conversion automatically.\n  // This is not intended to be a 100% bulletproof solution.\n  // If it doesn't work for your use-case, then use a URL instead.\n  let pathType = \"http\";\n  if (url.isFileSystemPath(args.path)) {\n    args.path = url.fromFileSystemPath(args.path);\n    pathType = \"file\";\n  }\n\n  // Resolve the absolute path of the schema\n  args.path = url.resolve(url.cwd(), args.path);\n\n  if (args.schema && typeof args.schema === \"object\") {\n    // A schema object was passed-in.\n    // So immediately add a new $Ref with the schema object as its value\n    let $ref = this.$refs._add(args.path);\n    $ref.value = args.schema;\n    $ref.pathType = pathType;\n    promise = Promise.resolve(args.schema);\n  }\n  else {\n    // Parse the schema file/url\n    promise = parse(args.path, this.$refs, args.options);\n  }\n\n  let me = this;\n  try {\n    let result = await promise;\n\n    if (!result || typeof result !== \"object\" || Buffer.isBuffer(result)) {\n      throw ono.syntax(`\"${me.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n    }\n    else {\n      me.schema = result;\n      return maybe(args.callback, Promise.resolve(me.schema));\n    }\n  }\n  catch (e) {\n    return maybe(args.callback, Promise.reject(e));\n  }\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.resolve = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.prototype.resolve = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.parse(args.path, args.schema, args.options);\n    await resolveExternal(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.$refs));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.bundle = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.prototype.bundle = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    bundle(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.dereference = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.prototype.dereference = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    dereference(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n"]},"metadata":{},"sourceType":"script"}