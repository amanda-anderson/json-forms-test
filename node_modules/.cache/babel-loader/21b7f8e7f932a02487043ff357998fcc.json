{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require(\"ono\"),\n    ono = _require.ono;\n\nvar url = require(\"./util/url\");\n\nvar plugins = require(\"./util/plugins\");\n\nmodule.exports = parse;\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\n\nfunction parse(_x, _x2, _x3) {\n  return _parse.apply(this, arguments);\n}\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\n\n\nfunction _parse() {\n  _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, $refs, options) {\n    var $ref, file, resolver, parser;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            // Remove the URL fragment, if any\n            path = url.stripHash(path); // Add a new $Ref for this file, even though we don't have the value yet.\n            // This ensures that we don't simultaneously read & parse the same file multiple times\n\n            $ref = $refs._add(path); // This \"file object\" will be passed to all resolvers and parsers.\n\n            file = {\n              url: path,\n              extension: url.getExtension(path)\n            }; // Read the file and then parse the data\n\n            _context.next = 6;\n            return readFile(file, options, $refs);\n\n          case 6:\n            resolver = _context.sent;\n            $ref.pathType = resolver.plugin.name;\n            file.data = resolver.result;\n            _context.next = 11;\n            return parseFile(file, options, $refs);\n\n          case 11:\n            parser = _context.sent;\n            $ref.value = parser.result;\n            return _context.abrupt(\"return\", parser.result);\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](0);\n            return _context.abrupt(\"return\", Promise.reject(_context.t0));\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 16]]);\n  }));\n  return _parse.apply(this, arguments);\n}\n\nfunction readFile(file, options, $refs) {\n  return new Promise(function (resolve, reject) {\n    // console.log('Reading %s', file.url);\n    // Find the resolvers that can read this file\n    var resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file); // Run the resolvers, in order, until one of them succeeds\n\n    plugins.sort(resolvers);\n    plugins.run(resolvers, \"read\", file, $refs).then(resolve, onError);\n\n    function onError(err) {\n      // Throw the original error, if it's one of our own (user-friendly) errors.\n      // Otherwise, throw a generic, friendly error.\n      if (err && !(err instanceof SyntaxError)) {\n        reject(err);\n      } else {\n        reject(ono.syntax(\"Unable to resolve $ref pointer \\\"\".concat(file.url, \"\\\"\")));\n      }\n    }\n  });\n}\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\n\n\nfunction parseFile(file, options, $refs) {\n  return new Promise(function (resolve, reject) {\n    // console.log('Parsing %s', file.url);\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    var allParsers = plugins.all(options.parse);\n    var filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    var parsers = filteredParsers.length > 0 ? filteredParsers : allParsers; // Run the parsers, in order, until one of them succeeds\n\n    plugins.sort(parsers);\n    plugins.run(parsers, \"parse\", file, $refs).then(onParsed, onError);\n\n    function onParsed(parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(\"Error parsing \\\"\".concat(file.url, \"\\\" as \").concat(parser.plugin.name, \". \\nParsed value is empty\")));\n      } else {\n        resolve(parser);\n      }\n    }\n\n    function onError(err) {\n      if (err) {\n        err = err instanceof Error ? err : new Error(err);\n        reject(ono.syntax(err, \"Error parsing \".concat(file.url)));\n      } else {\n        reject(ono.syntax(\"Unable to parse \".concat(file.url)));\n      }\n    }\n  });\n}\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\n\n\nfunction isEmpty(value) {\n  return value === undefined || typeof value === \"object\" && Object.keys(value).length === 0 || typeof value === \"string\" && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;\n}","map":{"version":3,"sources":["/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/json-schema-ref-parser/lib/parse.js"],"names":["require","ono","url","plugins","module","exports","parse","path","$refs","options","stripHash","$ref","_add","file","extension","getExtension","readFile","resolver","pathType","plugin","name","data","result","parseFile","parser","value","Promise","reject","resolve","resolvers","all","filter","sort","run","then","onError","err","SyntaxError","syntax","allParsers","filteredParsers","parsers","length","onParsed","allowEmpty","isEmpty","Error","undefined","Object","keys","trim","Buffer","isBuffer"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { ono } = require(\"ono\");\nconst url = require(\"./util/url\");\nconst plugins = require(\"./util/plugins\");\n\nmodule.exports = parse;\n\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\nasync function parse (path, $refs, options) {\n  try {\n    // Remove the URL fragment, if any\n    path = url.stripHash(path);\n\n    // Add a new $Ref for this file, even though we don't have the value yet.\n    // This ensures that we don't simultaneously read & parse the same file multiple times\n    let $ref = $refs._add(path);\n\n    // This \"file object\" will be passed to all resolvers and parsers.\n    let file = {\n      url: path,\n      extension: url.getExtension(path),\n    };\n\n    // Read the file and then parse the data\n    const resolver = await readFile(file, options, $refs);\n    $ref.pathType = resolver.plugin.name;\n    file.data = resolver.result;\n\n    const parser = await parseFile(file, options, $refs);\n    $ref.value = parser.result;\n\n    return parser.result;\n  }\n  catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nfunction readFile (file, options, $refs) {\n  return new Promise(((resolve, reject) => {\n    // console.log('Reading %s', file.url);\n\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file);\n\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    plugins.run(resolvers, \"read\", file, $refs)\n      .then(resolve, onError);\n\n    function onError (err) {\n      // Throw the original error, if it's one of our own (user-friendly) errors.\n      // Otherwise, throw a generic, friendly error.\n      if (err && !(err instanceof SyntaxError)) {\n        reject(err);\n      }\n      else {\n        reject(ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`));\n      }\n    }\n  }));\n}\n\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nfunction parseFile (file, options, $refs) {\n  return new Promise(((resolve, reject) => {\n    // console.log('Parsing %s', file.url);\n\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    let allParsers = plugins.all(options.parse);\n    let filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    plugins.run(parsers, \"parse\", file, $refs)\n      .then(onParsed, onError);\n\n    function onParsed (parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`));\n      }\n      else {\n        resolve(parser);\n      }\n    }\n\n    function onError (err) {\n      if (err) {\n        err = err instanceof Error ? err : new Error(err);\n        reject(ono.syntax(err, `Error parsing ${file.url}`));\n      }\n      else {\n        reject(ono.syntax(`Unable to parse ${file.url}`));\n      }\n    }\n  }));\n}\n\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\nfunction isEmpty (value) {\n  return value === undefined ||\n    (typeof value === \"object\" && Object.keys(value).length === 0) ||\n    (typeof value === \"string\" && value.trim().length === 0) ||\n    (Buffer.isBuffer(value) && value.length === 0);\n}\n"]},"metadata":{},"sourceType":"script"}