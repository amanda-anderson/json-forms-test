{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"../../compile/util\");\n\nvar def = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n\n  code(cxt) {\n    var gen = cxt.gen,\n        schema = cxt.schema,\n        it = cxt.it;\n\n    if ((0, util_1.alwaysValidSchema)(it, schema)) {\n      cxt.fail();\n      return;\n    }\n\n    var valid = gen.name(\"valid\");\n    cxt.subschema({\n      keyword: \"not\",\n      compositeRule: true,\n      createErrors: false,\n      allErrors: false\n    }, valid);\n    cxt.failResult(valid, function () {\n      return cxt.reset();\n    }, function () {\n      return cxt.error();\n    });\n  },\n\n  error: {\n    message: \"must NOT be valid\"\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/not.ts"],"names":[],"mappings":";;;;;;AAEA,IAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAIA,IAAM,GAAG,GAA0B;AACjC,EAAA,OAAO,EAAE,KADwB;AAEjC,EAAA,UAAU,EAAE,CAAC,QAAD,EAAW,SAAX,CAFqB;AAGjC,EAAA,WAAW,EAAE,IAHoB;;AAIjC,EAAA,IAAI,CAAC,GAAD,EAAgB;AAAA,QACX,GADW,GACQ,GADR,CACX,GADW;AAAA,QACN,MADM,GACQ,GADR,CACN,MADM;AAAA,QACE,EADF,GACQ,GADR,CACE,EADF;;AAElB,QAAI,CAAA,GAAA,MAAA,CAAA,iBAAA,EAAkB,EAAlB,EAAsB,MAAtB,CAAJ,EAAmC;AACjC,MAAA,GAAG,CAAC,IAAJ;AACA;AACD;;AAED,QAAM,KAAK,GAAG,GAAG,CAAC,IAAJ,CAAS,OAAT,CAAd;AACA,IAAA,GAAG,CAAC,SAAJ,CACE;AACE,MAAA,OAAO,EAAE,KADX;AAEE,MAAA,aAAa,EAAE,IAFjB;AAGE,MAAA,YAAY,EAAE,KAHhB;AAIE,MAAA,SAAS,EAAE;AAJb,KADF,EAOE,KAPF;AAUA,IAAA,GAAG,CAAC,UAAJ,CACE,KADF,EAEE;AAAA,aAAM,GAAG,CAAC,KAAJ,EAAN;AAAA,KAFF,EAGE;AAAA,aAAM,GAAG,CAAC,KAAJ,EAAN;AAAA,KAHF;AAKD,GA3BgC;;AA4BjC,EAAA,KAAK,EAAE;AAAC,IAAA,OAAO,EAAE;AAAV;AA5B0B,CAAnC;AA+BA,OAAA,CAAA,OAAA,GAAe,GAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports.default = def;\n//# sourceMappingURL=not.js.map"]},"metadata":{},"sourceType":"script"}