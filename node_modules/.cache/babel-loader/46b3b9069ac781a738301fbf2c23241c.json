{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"[\", \", \", \"]\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\", \" && \", \"\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"{passingSchemas: \", \"}\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: \"must match exactly one schema in oneOf\",\n  params: function params(_ref) {\n    var _params = _ref.params;\n    return (0, codegen_1._)(_templateObject(), _params.passing);\n  }\n};\nvar def = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    var gen = cxt.gen,\n        schema = cxt.schema,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    /* istanbul ignore if */\n\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    if (it.opts.discriminator && parentSchema.discriminator) return;\n    var schArr = schema;\n    var valid = gen.let(\"valid\", false);\n    var passing = gen.let(\"passing\", null);\n    var schValid = gen.name(\"_valid\");\n    cxt.setParams({\n      passing\n    }); // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf);\n    cxt.result(valid, function () {\n      return cxt.reset();\n    }, function () {\n      return cxt.error(true);\n    });\n\n    function validateOneOf() {\n      schArr.forEach(function (sch, i) {\n        var schCxt;\n\n        if ((0, util_1.alwaysValidSchema)(it, sch)) {\n          gen.var(schValid, true);\n        } else {\n          schCxt = cxt.subschema({\n            keyword: \"oneOf\",\n            schemaProp: i,\n            compositeRule: true\n          }, schValid);\n        }\n\n        if (i > 0) {\n          gen.if((0, codegen_1._)(_templateObject2(), schValid, valid)).assign(valid, false).assign(passing, (0, codegen_1._)(_templateObject3(), passing, i)).else();\n        }\n\n        gen.if(schValid, function () {\n          gen.assign(valid, true);\n          gen.assign(passing, i);\n          if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);\n        });\n      });\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/oneOf.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,IAAA,SAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AASA,IAAM,KAAK,GAA2B;AACpC,EAAA,OAAO,EAAE,wCAD2B;AAEpC,EAAA,MAAM,EAAE;AAAA,QAAE,OAAF,QAAE,MAAF;AAAA,YAAc,GAAA,SAAA,CAAA,CAAd,qBAAmC,OAAM,CAAC,OAA1C;AAAA;AAF4B,CAAtC;AAKA,IAAM,GAAG,GAA0B;AACjC,EAAA,OAAO,EAAE,OADwB;AAEjC,EAAA,UAAU,EAAE,OAFqB;AAGjC,EAAA,WAAW,EAAE,IAHoB;AAIjC,EAAA,KAJiC;;AAKjC,EAAA,IAAI,CAAC,GAAD,EAAgB;AAAA,QACX,GADW,GACsB,GADtB,CACX,GADW;AAAA,QACN,MADM,GACsB,GADtB,CACN,MADM;AAAA,QACE,YADF,GACsB,GADtB,CACE,YADF;AAAA,QACgB,EADhB,GACsB,GADtB,CACgB,EADhB;AAElB;;AACA,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAAL,EAA4B,MAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AAC5B,QAAI,EAAE,CAAC,IAAH,CAAQ,aAAR,IAAyB,YAAY,CAAC,aAA1C,EAAyD;AACzD,QAAM,MAAM,GAAgB,MAA5B;AACA,QAAM,KAAK,GAAG,GAAG,CAAC,GAAJ,CAAQ,OAAR,EAAiB,KAAjB,CAAd;AACA,QAAM,OAAO,GAAG,GAAG,CAAC,GAAJ,CAAQ,SAAR,EAAmB,IAAnB,CAAhB;AACA,QAAM,QAAQ,GAAG,GAAG,CAAC,IAAJ,CAAS,QAAT,CAAjB;AACA,IAAA,GAAG,CAAC,SAAJ,CAAc;AAAC,MAAA;AAAD,KAAd,EATkB,CAUlB;;AAEA,IAAA,GAAG,CAAC,KAAJ,CAAU,aAAV;AAEA,IAAA,GAAG,CAAC,MAAJ,CACE,KADF,EAEE;AAAA,aAAM,GAAG,CAAC,KAAJ,EAAN;AAAA,KAFF,EAGE;AAAA,aAAM,GAAG,CAAC,KAAJ,CAAU,IAAV,CAAN;AAAA,KAHF;;AAMA,aAAS,aAAT,GAAsB;AACpB,MAAA,MAAM,CAAC,OAAP,CAAe,UAAC,GAAD,EAAiB,CAAjB,EAA8B;AAC3C,YAAI,MAAJ;;AACA,YAAI,CAAA,GAAA,MAAA,CAAA,iBAAA,EAAkB,EAAlB,EAAsB,GAAtB,CAAJ,EAAgC;AAC9B,UAAA,GAAG,CAAC,GAAJ,CAAQ,QAAR,EAAkB,IAAlB;AACD,SAFD,MAEO;AACL,UAAA,MAAM,GAAG,GAAG,CAAC,SAAJ,CACP;AACE,YAAA,OAAO,EAAE,OADX;AAEE,YAAA,UAAU,EAAE,CAFd;AAGE,YAAA,aAAa,EAAE;AAHjB,WADO,EAMP,QANO,CAAT;AAQD;;AAED,YAAI,CAAC,GAAG,CAAR,EAAW;AACT,UAAA,GAAG,CACA,EADH,EACM,GAAA,SAAA,CAAA,CADN,sBACU,QADV,EACyB,KADzB,GAEG,MAFH,CAEU,KAFV,EAEiB,KAFjB,EAGG,MAHH,CAGU,OAHV,GAGmB,GAAA,SAAA,CAAA,CAHnB,sBAGwB,OAHxB,EAGoC,CAHpC,GAIG,IAJH;AAKD;;AAED,QAAA,GAAG,CAAC,EAAJ,CAAO,QAAP,EAAiB,YAAK;AACpB,UAAA,GAAG,CAAC,MAAJ,CAAW,KAAX,EAAkB,IAAlB;AACA,UAAA,GAAG,CAAC,MAAJ,CAAW,OAAX,EAAoB,CAApB;AACA,cAAI,MAAJ,EAAY,GAAG,CAAC,cAAJ,CAAmB,MAAnB,EAA2B,SAAA,CAAA,IAA3B;AACb,SAJD;AAKD,OA5BD;AA6BD;AACF;;AAxDgC,CAAnC;AA2DA,OAAA,CAAA,OAAA,GAAe,GAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=oneOf.js.map"]},"metadata":{},"sourceType":"script"}