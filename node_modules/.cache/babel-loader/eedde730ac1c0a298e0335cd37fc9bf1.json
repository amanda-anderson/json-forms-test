{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteral([\"\", \" === \", \"\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\", \"(\", \", \", \"[\", \"])\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\", \"(\", \", \", \")\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"{allowedValues: \", \"}\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar equal_1 = require(\"../../runtime/equal\");\n\nvar error = {\n  message: \"must be equal to one of the allowed values\",\n  params: function params(_ref) {\n    var schemaCode = _ref.schemaCode;\n    return (0, codegen_1._)(_templateObject(), schemaCode);\n  }\n};\nvar def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        $data = cxt.$data,\n        schema = cxt.schema,\n        schemaCode = cxt.schemaCode,\n        it = cxt.it;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    var useLoop = schema.length >= it.opts.loopEnum;\n    var eql;\n\n    var getEql = function getEql() {\n      return eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);\n    };\n\n    var valid;\n\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      var vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = (0, codegen_1.or).apply(void 0, _toConsumableArray(schema.map(function (_x, i) {\n        return equalCode(vSchema, i);\n      })));\n    }\n\n    cxt.pass(valid);\n\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, function (v) {\n        return gen.if((0, codegen_1._)(_templateObject2(), getEql(), data, v), function () {\n          return gen.assign(valid, true).break();\n        });\n      });\n    }\n\n    function equalCode(vSchema, i) {\n      var sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)(_templateObject3(), getEql(), data, vSchema, i) : (0, codegen_1._)(_templateObject4(), data, sch);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/enum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}