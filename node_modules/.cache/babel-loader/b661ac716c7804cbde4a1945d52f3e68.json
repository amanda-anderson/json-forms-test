{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"{missingProperty: \", \"}\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"must have required property '\", \"'\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar code_1 = require(\"../code\");\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: function message(_ref) {\n    var missingProperty = _ref.params.missingProperty;\n    return (0, codegen_1.str)(_templateObject(), missingProperty);\n  },\n  params: function params(_ref2) {\n    var missingProperty = _ref2.params.missingProperty;\n    return (0, codegen_1._)(_templateObject2(), missingProperty);\n  }\n};\nvar def = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    var gen = cxt.gen,\n        schema = cxt.schema,\n        schemaCode = cxt.schemaCode,\n        data = cxt.data,\n        $data = cxt.$data,\n        it = cxt.it;\n    var opts = it.opts;\n    if (!$data && schema.length === 0) return;\n    var useLoop = schema.length >= opts.loopRequired;\n    if (it.allErrors) allErrorsMode();else exitOnErrorMode();\n\n    if (opts.strictRequired) {\n      var props = cxt.parentSchema.properties;\n      var definedProperties = cxt.it.definedProperties;\n\n      var _iterator = _createForOfIteratorHelper(schema),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var requiredKey = _step.value;\n\n          if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n            var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n            var msg = \"required property \\\"\".concat(requiredKey, \"\\\" is not defined at \\\"\").concat(schemaPath, \"\\\" (strictRequired)\");\n            (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    function allErrorsMode() {\n      if (useLoop || $data) {\n        cxt.block$data(codegen_1.nil, loopAllRequired);\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(schema),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var prop = _step2.value;\n            (0, code_1.checkReportMissingProp)(cxt, prop);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n\n    function exitOnErrorMode() {\n      var missing = gen.let(\"missing\");\n\n      if (useLoop || $data) {\n        var valid = gen.let(\"valid\", true);\n        cxt.block$data(valid, function () {\n          return loopUntilMissing(missing, valid);\n        });\n        cxt.ok(valid);\n      } else {\n        gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n        (0, code_1.reportMissingProp)(cxt, missing);\n        gen.else();\n      }\n    }\n\n    function loopAllRequired() {\n      gen.forOf(\"prop\", schemaCode, function (prop) {\n        cxt.setParams({\n          missingProperty: prop\n        });\n        gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), function () {\n          return cxt.error();\n        });\n      });\n    }\n\n    function loopUntilMissing(missing, valid) {\n      cxt.setParams({\n        missingProperty: missing\n      });\n      gen.forOf(missing, schemaCode, function () {\n        gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n        gen.if((0, codegen_1.not)(valid), function () {\n          cxt.error();\n          gen.break();\n        });\n      }, codegen_1.nil);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/required.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=required.js.map"]},"metadata":{},"sourceType":"script"}