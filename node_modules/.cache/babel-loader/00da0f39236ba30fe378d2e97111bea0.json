{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\", \".errors\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\n\nvar errors_1 = require(\"../errors\");\n\nvar codegen_1 = require(\"../codegen\");\n\nvar names_1 = require(\"../names\");\n\nvar boolError = {\n  message: \"boolean schema is false\"\n};\n\nfunction topBoolOrEmptySchema(it) {\n  var gen = it.gen,\n      schema = it.schema,\n      validateName = it.validateName;\n\n  if (schema === false) {\n    falseSchemaError(it, false);\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(names_1.default.data);\n  } else {\n    gen.assign((0, codegen_1._)(_templateObject(), validateName), null);\n    gen.return(true);\n  }\n}\n\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\n\nfunction boolOrEmptySchema(it, valid) {\n  var gen = it.gen,\n      schema = it.schema;\n\n  if (schema === false) {\n    gen.var(valid, false); // TODO var\n\n    falseSchemaError(it);\n  } else {\n    gen.var(valid, true); // TODO var\n  }\n}\n\nexports.boolOrEmptySchema = boolOrEmptySchema;\n\nfunction falseSchemaError(it, overrideAllErrors) {\n  var gen = it.gen,\n      data = it.data; // TODO maybe some other interface should be used for non-keyword validation errors...\n\n  var cxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it\n  };\n  (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}","map":{"version":3,"sources":["../../../lib/compile/validate/boolSchema.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,IAAM,SAAS,GAA2B;AACxC,EAAA,OAAO,EAAE;AAD+B,CAA1C;;AAIA,SAAgB,oBAAhB,CAAqC,EAArC,EAAkD;AAAA,MACzC,GADyC,GACZ,EADY,CACzC,GADyC;AAAA,MACpC,MADoC,GACZ,EADY,CACpC,MADoC;AAAA,MAC5B,YAD4B,GACZ,EADY,CAC5B,YAD4B;;AAEhD,MAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,IAAA,gBAAgB,CAAC,EAAD,EAAK,KAAL,CAAhB;AACD,GAFD,MAEO,IAAI,OAAO,MAAP,IAAiB,QAAjB,IAA6B,MAAM,CAAC,MAAP,KAAkB,IAAnD,EAAyD;AAC9D,IAAA,GAAG,CAAC,MAAJ,CAAW,OAAA,CAAA,OAAA,CAAE,IAAb;AACD,GAFM,MAEA;AACL,IAAA,GAAG,CAAC,MAAJ,EAAW,GAAA,SAAA,CAAA,CAAX,qBAAe,YAAf,GAAsC,IAAtC;AACA,IAAA,GAAG,CAAC,MAAJ,CAAW,IAAX;AACD;AACF;;AAVD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAYA,SAAgB,iBAAhB,CAAkC,EAAlC,EAAiD,KAAjD,EAA4D;AAAA,MACnD,GADmD,GACpC,EADoC,CACnD,GADmD;AAAA,MAC9C,MAD8C,GACpC,EADoC,CAC9C,MAD8C;;AAE1D,MAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,IAAA,GAAG,CAAC,GAAJ,CAAQ,KAAR,EAAe,KAAf,EADoB,CACE;;AACtB,IAAA,gBAAgB,CAAC,EAAD,CAAhB;AACD,GAHD,MAGO;AACL,IAAA,GAAG,CAAC,GAAJ,CAAQ,KAAR,EAAe,IAAf,EADK,CACgB;AACtB;AACF;;AARD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAUA,SAAS,gBAAT,CAA0B,EAA1B,EAAyC,iBAAzC,EAAoE;AAAA,MAC3D,GAD2D,GAC9C,EAD8C,CAC3D,GAD2D;AAAA,MACtD,IADsD,GAC9C,EAD8C,CACtD,IADsD,EAElE;;AACA,MAAM,GAAG,GAAoB;AAC3B,IAAA,GAD2B;AAE3B,IAAA,OAAO,EAAE,cAFkB;AAG3B,IAAA,IAH2B;AAI3B,IAAA,MAAM,EAAE,KAJmB;AAK3B,IAAA,UAAU,EAAE,KALe;AAM3B,IAAA,WAAW,EAAE,KANc;AAO3B,IAAA,MAAM,EAAE,EAPmB;AAQ3B,IAAA;AAR2B,GAA7B;AAUA,GAAA,GAAA,QAAA,CAAA,WAAA,EAAY,GAAZ,EAAiB,SAAjB,EAA4B,SAA5B,EAAuC,iBAAvC;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map"]},"metadata":{},"sourceType":"script"}