{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject5() {\n  var data = _taggedTemplateLiteral([\"\", \" <= \", \"\"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteral([\"\", \" <= \", \"\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\", \".length\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"{limit: \", \"}\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"must NOT have more than \", \" items\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateAdditionalItems = void 0;\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: function message(_ref) {\n    var len = _ref.params.len;\n    return (0, codegen_1.str)(_templateObject(), len);\n  },\n  params: function params(_ref2) {\n    var len = _ref2.params.len;\n    return (0, codegen_1._)(_templateObject2(), len);\n  }\n};\nvar def = {\n  keyword: \"additionalItems\",\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n\n  code(cxt) {\n    var parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    var items = parentSchema.items;\n\n    if (!Array.isArray(items)) {\n      (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n      return;\n    }\n\n    validateAdditionalItems(cxt, items);\n  }\n\n};\n\nfunction validateAdditionalItems(cxt, items) {\n  var gen = cxt.gen,\n      schema = cxt.schema,\n      data = cxt.data,\n      keyword = cxt.keyword,\n      it = cxt.it;\n  it.items = true;\n  var len = gen.const(\"len\", (0, codegen_1._)(_templateObject3(), data));\n\n  if (schema === false) {\n    cxt.setParams({\n      len: items.length\n    });\n    cxt.pass((0, codegen_1._)(_templateObject4(), len, items.length));\n  } else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n    var valid = gen.var(\"valid\", (0, codegen_1._)(_templateObject5(), len, items.length)); // TODO var\n\n    gen.if((0, codegen_1.not)(valid), function () {\n      return validateItems(valid);\n    });\n    cxt.ok(valid);\n  }\n\n  function validateItems(valid) {\n    gen.forRange(\"i\", items.length, len, function (i) {\n      cxt.subschema({\n        keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      if (!it.allErrors) gen.if((0, codegen_1.not)(valid), function () {\n        return gen.break();\n      });\n    });\n  }\n}\n\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/additionalItems.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;\n//# sourceMappingURL=additionalItems.js.map"]},"metadata":{},"sourceType":"script"}