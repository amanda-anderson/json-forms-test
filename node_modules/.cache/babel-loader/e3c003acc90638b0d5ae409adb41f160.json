{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\", \"\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"{failingKeyword: \", \"}\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"must match \\\"\", \"\\\" schema\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: function message(_ref) {\n    var params = _ref.params;\n    return (0, codegen_1.str)(_templateObject(), params.ifClause);\n  },\n  params: function params(_ref2) {\n    var _params = _ref2.params;\n    return (0, codegen_1._)(_templateObject2(), _params.ifClause);\n  }\n};\nvar def = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    var gen = cxt.gen,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n    }\n\n    var hasThen = hasSchema(it, \"then\");\n    var hasElse = hasSchema(it, \"else\");\n    if (!hasThen && !hasElse) return;\n    var valid = gen.let(\"valid\", true);\n    var schValid = gen.name(\"_valid\");\n    validateIf();\n    cxt.reset();\n\n    if (hasThen && hasElse) {\n      var ifClause = gen.let(\"ifClause\");\n      cxt.setParams({\n        ifClause\n      });\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"));\n    } else {\n      gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n    }\n\n    cxt.pass(valid, function () {\n      return cxt.error(true);\n    });\n\n    function validateIf() {\n      var schCxt = cxt.subschema({\n        keyword: \"if\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false\n      }, schValid);\n      cxt.mergeEvaluated(schCxt);\n    }\n\n    function validateClause(keyword, ifClause) {\n      return function () {\n        var schCxt = cxt.subschema({\n          keyword\n        }, schValid);\n        gen.assign(valid, schValid);\n        cxt.mergeValidEvaluated(schCxt, valid);\n        if (ifClause) gen.assign(ifClause, (0, codegen_1._)(_templateObject3(), keyword));else cxt.setParams({\n          ifClause: keyword\n        });\n      };\n    }\n  }\n\n};\n\nfunction hasSchema(it, keyword) {\n  var schema = it.schema[keyword];\n  return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\n\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/if.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;\n//# sourceMappingURL=if.js.map"]},"metadata":{},"sourceType":"script"}