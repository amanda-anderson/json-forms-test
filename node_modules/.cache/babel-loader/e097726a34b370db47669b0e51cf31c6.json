{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _createForOfIteratorHelper = require(\"/home/aander-cl/Documents/jsonforms/jsonforms-react-seed/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\", \"[\", \"]\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\", \".test(\", \")\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar code_1 = require(\"../code\");\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar util_2 = require(\"../../compile/util\");\n\nvar def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n\n  code(cxt) {\n    var gen = cxt.gen,\n        schema = cxt.schema,\n        data = cxt.data,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    var opts = it.opts;\n    var patterns = (0, code_1.allSchemaProperties)(schema);\n    var alwaysValidPatterns = patterns.filter(function (p) {\n      return (0, util_1.alwaysValidSchema)(it, schema[p]);\n    });\n\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n\n    var checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    var valid = gen.name(\"valid\");\n\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n    }\n\n    var props = it.props;\n    validatePatternProperties();\n\n    function validatePatternProperties() {\n      var _iterator = _createForOfIteratorHelper(patterns),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pat = _step.value;\n          if (checkProperties) checkMatchingProperties(pat);\n\n          if (it.allErrors) {\n            validateProperties(pat);\n          } else {\n            gen.var(valid, true); // TODO var\n\n            validateProperties(pat);\n            gen.if(valid);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    function checkMatchingProperties(pat) {\n      for (var prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          (0, util_1.checkStrictMode)(it, \"property \".concat(prop, \" matches pattern \").concat(pat, \" (use allowMatchingProperties)\"));\n        }\n      }\n    }\n\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, function (key) {\n        gen.if((0, codegen_1._)(_templateObject(), (0, code_1.usePattern)(cxt, pat), key), function () {\n          var alwaysValid = alwaysValidPatterns.includes(pat);\n\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign((0, codegen_1._)(_templateObject2(), props, key), true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if((0, codegen_1.not)(valid), function () {\n              return gen.break();\n            });\n          }\n        });\n      });\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/patternProperties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map"]},"metadata":{},"sourceType":"script"}