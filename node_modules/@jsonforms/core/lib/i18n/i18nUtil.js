"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCombinedErrorMessage = exports.defaultErrorTranslator = exports.defaultTranslator = exports.getI18nKey = exports.getI18nKeyPrefix = exports.transformPathToI18nPrefix = exports.getI18nKeyPrefixBySchema = void 0;
var reducers_1 = require("../reducers");
var util_1 = require("../util");
var getI18nKeyPrefixBySchema = function (schema, uischema) {
    var _a, _b, _c;
    return (_c = (_b = (_a = uischema === null || uischema === void 0 ? void 0 : uischema.options) === null || _a === void 0 ? void 0 : _a.i18n) !== null && _b !== void 0 ? _b : schema === null || schema === void 0 ? void 0 : schema.i18n) !== null && _c !== void 0 ? _c : undefined;
};
exports.getI18nKeyPrefixBySchema = getI18nKeyPrefixBySchema;
/**
 * Transforms a given path to a prefix which can be used for i18n keys.
 * Returns 'root' for empty paths and removes array indices
 */
var transformPathToI18nPrefix = function (path) {
    return ((path === null || path === void 0 ? void 0 : path.split('.').filter(function (segment) { return !/^\d+$/.test(segment); }).join('.')) || 'root');
};
exports.transformPathToI18nPrefix = transformPathToI18nPrefix;
var getI18nKeyPrefix = function (schema, uischema, path) {
    var _a;
    return ((_a = exports.getI18nKeyPrefixBySchema(schema, uischema)) !== null && _a !== void 0 ? _a : exports.transformPathToI18nPrefix(path));
};
exports.getI18nKeyPrefix = getI18nKeyPrefix;
var getI18nKey = function (schema, uischema, path, key) {
    return exports.getI18nKeyPrefix(schema, uischema, path) + "." + key;
};
exports.getI18nKey = getI18nKey;
var defaultTranslator = function (_id, defaultMessage) { return defaultMessage; };
exports.defaultTranslator = defaultTranslator;
var defaultErrorTranslator = function (error, t, uischema) {
    var _a;
    // check whether there is a special keyword message
    var i18nKey = exports.getI18nKey(error.parentSchema, uischema, reducers_1.getControlPath(error), "error." + error.keyword);
    var specializedKeywordMessage = t(i18nKey, undefined);
    if (specializedKeywordMessage !== undefined) {
        return specializedKeywordMessage;
    }
    // check whether there is a generic keyword message
    var genericKeywordMessage = t("error." + error.keyword, undefined);
    if (genericKeywordMessage !== undefined) {
        return genericKeywordMessage;
    }
    // check whether there is a customization for the default message
    var messageCustomization = t(error.message, undefined);
    if (messageCustomization !== undefined) {
        return messageCustomization;
    }
    // rewrite required property messages (if they were not customized) as we place them next to the respective input
    if (error.keyword === 'required' && ((_a = error.message) === null || _a === void 0 ? void 0 : _a.startsWith('must have required property'))) {
        return t('is a required property', 'is a required property');
    }
    return error.message;
};
exports.defaultErrorTranslator = defaultErrorTranslator;
/**
 * Returns the determined error message for the given errors.
 * All errors must correspond to the given schema, uischema or path.
 */
var getCombinedErrorMessage = function (errors, et, t, schema, uischema, path) {
    if (errors.length > 0 && t) {
        // check whether there is a special message which overwrites all others
        var customErrorKey = exports.getI18nKey(schema, uischema, path, 'error.custom');
        var specializedErrorMessage = t(customErrorKey, undefined);
        if (specializedErrorMessage !== undefined) {
            return specializedErrorMessage;
        }
    }
    return util_1.formatErrorMessage(errors.map(function (error) { return et(error, t, uischema); }));
};
exports.getCombinedErrorMessage = getCombinedErrorMessage;
//# sourceMappingURL=i18nUtil.js.map